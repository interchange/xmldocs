#!/usr/bin/perl

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

{ no warnings;
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;
}

my $force_regenerate = 1; # Rebuild pages even if they exist
my $dumpdb = 0;
my $verbose = 0;
my $OUTPUT = "OUTPUT";
my %refcache; # memory cache of Storable files. Not really needed but I 
              # copied old code which had it, so ...
my %hash; # complete tree data
my $cachedir = $ENV{CACHE} || "cache";
my %i; # internally derived data
my %autogenerated; # Data for symbols autogenerated in this run
my %invalid; # Information about missing documentation
my %covered; # Weed out duplicate context reports
my %symbol_lists; # symbols listed in categories
my %symbols; # FINAL symbol refentries
my @template = <DATA>;

my @page_order = (qw/purpose synopsis description example notes bugs/, "symbol type", "source", "author", "copyright", "see also");

unless ( GetOptions ( 
	"verbosedb|dumpdb|d!" => \$dumpdb,
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV or die "Usage: $0 version[s]\n";

my %longname = (
	globvar => "Global Variable",
	pragma => "Pragma",
);

# General description of symbol types
my %general_desc;
opendir DIR, "docbook/symbol-type-skel";
while ( my $file = readdir DIR ) {
	next if $file =~ /^\.|^CVS$/;
	open INF, "< docbook/symbol-type-skel/$file" or
		die "Can't open docbook/symbol-type-skel/$file ($!)\n";
	$general_desc{$file} = join "", <INF>;
	close INF;
}
closedir DIR;

# Default fields
my %defaults = (
	synopsis => "No synopsis line",

	description => "No more specific information 
	was supplied. Interchange documentation is being reorganized, and
	we're also trying to fill in the missing pieces along the way.
	We appologize for inconvenience.",

	example => "No examples are available at this time. We do consider this a problem and will try to supply some.",

	notes => "None.",
	
	bugs => "There are no known bugs.</para><para>If you believe you've found a bug, please write to interchange-users\@icdevgroup.org or use <application>reportbug</application> to submit bugs in Debian GNU.",

	'symbol type' => "No symbol type information, this is strange.",

	source => '',

	author => "Interchange Development Group",
	
	copyright => "2004  Interchange Development Group
	</para><para>
	This documentation and the source code are free; you can redistribute
	them and/or modify them
	under the terms of the GNU General Public License as published by the
	Free Software Foundation; either version 2 of the License, or (at your
	option) any later version.",
	
	'see also' => "No information.",

	purpose => "description line missing",
);

my @mandatory = (qw/synopsis example description purpose/, "symbol type");


my $path;
my $dumppath;
my $dumpdir;
my @paths = @ARGV;
my $lastpath;

while ( $path = shift @paths) {
	$lastpath = $path;
	$dumppath = $path;
	$i{ver} = $dumppath;
	$dumpdir = "$dumppath/";
	$dumppath .= "/.cache.bin";

	# Load DB
	loaddb( "$cachedir/$dumppath" );

	# This fills %autogenerated
	# Outer loop: symbol types (pragmas, globvars, ...)
	# Inner loop: actual symbols
	while ( my ($gkey,$gval) = each %{ $hash{symbols} } ) {
		for my $key (keys(%$gval)) {
			my $val = $gval->{$key};
			push @{ $symbol_lists{$gkey} }, $key
				unless grep {/^$key$/} @{ $symbol_lists{$gkey} };
			process_symbol($gkey, $key, $val);
			push @{ $autogenerated{$key}{"_available in"} }, $hash{version};
			$autogenerated{$key}{"available in"} =
				join ", ", @{ $autogenerated{$key}{"_available in"} };

			# Prepare source contexts, avoiding those cases
			# where a symbol appears multiple times inside the same
			# context lines span, but by stattree it gets counted
			# as a new context. (which is correct technically, but not
			# suitable for display).
			# 
			# Having this code in this loop will make all symbols
			# end up having the last version they appear in displayed in
			# source section.
			my $ag = $autogenerated{$key};
			my $ar = $hash{symbols}{ $$ag{"_symbol type"} }{$key};
			if ( @$ar ) { $$ag{source} = "" }
			for my $ctx ( @$ar ) {
				my ($fi, $ln, $ctxsize, $ctxdata) = @$ctx;
				my $loc = "$fi:$ln";
				for my $arr ( @{ $covered{$key}{$fi} } ) {
					goto DONELOOP if $ln > $$arr[0] and $ln < $$arr[1];
				}
				my $ctxsdata = join "", @$ctxdata;
				if ( length $ctxsdata ) {
					$$ag{source} .= <<ENDD;
<example>
<title>$loc ($ctxsize)</title>

<programlisting><![CDATA[
$ctxsdata
]]></programlisting>
</example>

ENDD
					$$ag{"source ver"} = $hash{version};
				}
				my ($less,$more) = split /:/, $ctxsize;
				push @{ $covered{$key}{$fi} }, [ $ln-$less, $ln+$more ];
				DONELOOP:
			}
		}
	}
}

# Final entry. That's where we add examples
# (which don't have version-specific data, they're always "latest")
while ( my($k,$v) = each %autogenerated ) {
	my %ag = %$v;

	$ag{name} ||= $ag{id} || $k;

	for my $field (@page_order) {
		if ( ! $ag{$field} ) {
			if ( grep {/$field/} @mandatory) {
				push @{ $invalid{$k} },
					"Missing field '$field', using unsuitable default";
			}
			$ag{$field} = $defaults{$field};
		}
	}

	# Do temporary-only modifications to %ag
	$ag{latest} = $hash{version};

	# Expand template
	my $template = join "", @template;
	{ no warnings;
	# I simply hate this, I can't find out which field
	# is undefined
	while ( $template =~ s/(\$ag{.*?})/$1/eem ) {};
	}

	# Save
	$symbols{$k} = $template;
}


# Produce reference sets
while (my ($k,$v) = each %symbol_lists ) {
	# Prepare reference page

	my $refpage = <<ENDD;
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook-Interchange XML V4.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<reference>
	<title>Interchange Reference Pages: $longname{$k}s</title>
ENDD

	## Add items
	for my $item (sort @$v) {
		$refpage .= $symbols{$item}
	}

	## Close up
	$refpage .= "\n" . '</reference>';

	# Dump page
	open OUT, "> refs/${k}s.xml" or
		die "Can't produce reference refs/$k.xml ($!)\n";
	print OUT $refpage;
	close OUT;
}

# Output the 'invalid' list
open INVOUT, "> tmp/missing" or
	die "Can't open tmp/missing ($!)\n";
print INVOUT Dumper \%invalid;
close INVOUT;

exit 0;

#################################################################
# Helpers below

sub process_symbol {
	my ($group, $name, $ref) = @_;

	return if ref $autogenerated{$name};

	# Make skel
	$autogenerated{$name} = {
		name => $name,
		id => $name,
		"_symbol type" => $group,
		"symbol type" => $general_desc{$group},
	};

	# Suplement with information from a control file
	populate($autogenerated{$name}, $name, 'control', 'override');
	populate($autogenerated{$name}, $name, '', 'append');
}

sub populate {
	my ($ref, $name, $file, $mode) = @_;

	# From one specific file (control file usually)
	if ( $file ) {
		open IN, "< refs/$name/$file" or do {
			push @{ $invalid{$name} }, "Requested file '$file' ($!)";
			return;
		};
		if ( $file eq 'control' ) {
			while (my $line = <IN>) {
				next if $line =~ /^\s*#/;
				chomp $line;
				$line =~ s/^\s+//;
				my ($sect,$text) = split /\s*:\s*/, $line, 2;
				goto SDONE if (!( defined $text and length $text ));
				if ( $mode eq 'override' ) {
					$$ref{lc $sect} = $text;
				} else {
					$$ref{lc $sect} .= '</para><para>' . $text;
				}
				SDONE:
			}
		}
		close IN;

	# From other file sets
	} elsif (! length $file) { # all files
		opendir INDIR, "refs/$name/" or do {
			push @{ $invalid{$name} }, "Missing directory (all other errors follow from this)";
			return;
		};
		while (my $fn = readdir INDIR) {
			next if $fn =~ /^\.|^CVS$/;
			next if $fn eq 'control';
			open INF, "< refs/$name/$fn" or
				die "Can't open refs/$name/$fn ($!)\n";

			( my $sect = $fn ) =~ s/[\-\.\+_:\d].*//;
			$sect =~ s/([a-z])([A-Z])/$1 $2/g;
			$sect = lc $sect;

			if (!( grep {/^$sect/} @page_order )) {
				push @{ $invalid{$name} }, "Section '$sect' from file '$fn' won't be used (name not recognized)";
			}
			
			my $content = join "", <INF>;
			close INF;

			if ( $mode eq 'override' ) {
				$$ref{$sect} = $content;
			} elsif ( $mode eq 'append' ) {
				$$ref{$sect} .= $content;
			}
		}
		closedir INDIR;

	} else {
		die "Parsing of specific, non-control files not implemented\n";
	}
}

sub loaddb {
	my $dbpath = shift;

	unless ( exists $refcache{$dbpath} ) {
		open( IN, "< $dbpath") or
			die "Can't open database ($dbpath) ($!).\n";
		flock( IN, LOCK_SH ) or
			die "Can't shared-lock database ($dbpath) ($!).\n";
		$refcache{$dbpath} = fd_retrieve( \*IN );
		close IN or
			die "Can't properly close database ($dbpath) ($!).\n";
	}

	%hash = %{ $refcache{$dbpath} };

	if ( $dumpdb ) {
		print STDERR Dumper \%hash;
		exit 0;
	}
}

sub O { print "@_\n"; print STDOUT "@_\n" if $verbose }

__DATA__
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7interchange</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1>
<title>SYNOPSIS</title>
$ag{"synopsis"}
</refsect1>

<refsect1>
<title>DEFAULT</title>
<para>$ag{"default"}</para>
</refsect1>

<refsect1>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1>
<title>BUGS</title>
<para>$ag{"bugs"}</para>
</refsect1>

<refsect1>
<title>SYMBOL TYPE</title>
<para>$ag{"symbol type"}</para>
</refsect1>

<refsect1>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in the following Interchange 
versions (including intermediates):
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1>
<title>SOURCE</title>
<para>The current Interchange development version (cvs-head) is $ag{"latest"}.
The $ag{"name"} symbol last appears in Interchange $ag{"source ver"}, in the
following contexts:</para>
$ag{source}
</refsect1>

<refsect1>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1>
<title>COPYRIGHT</title>
<para>$ag{"copyright"}</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>

