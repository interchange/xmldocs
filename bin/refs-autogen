#! /usr/bin/perl

# docelic@icdevgroup.org

# The script parses cache files made by bin/stattree, and generates
# the refs/*.xml files.

use warnings;
use strict;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

{ no warnings;
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;
}

my $dumpdb = 0;
my $verbose = 0;
my $OUTPUT = "OUTPUT";
my %refcache; # memory cache of Storable files. Not really needed but I 
              # copied old code which had it, so ...
my %hash; # complete tree data for each IC version we parse
my $cachedir = $ENV{CACHE} || "cache";
my %i; # internally derived data (only $i{ver} for now).
my %autogenerated; # Content of autogenerated symbols
my %invalid; # Information about missing documentation
my %covered; # Weed out duplicate context reports
my %symbol_lists; # symbols listed in categories
my %symbols; # FINAL symbol refentries
my %templates; # Templates for various symbol types
my $max_ctxs = 10; # Trim more than $max_ctxs source context reports
my @set_missing_all; # Helper to better manage %invalid
my @parsed_versions; # IC versions we parsed
my $specific_only; # Build only one specific .xml ?
my $output_spec; # 'list' produces tag list, 'xml' produces real xml source
my $output_both; # Unconditionally override $output_spec
my $no_autodefs; # Generate autodefs.ent collection of entities by default
my $autopath = "docbook/autorefs.ent";
my %dups; # List of symbols names that are not unique
my $last_path; # Last path we want docs generated for (say, 5.2.0).

my @page_order = (qw/purpose default structure synopsis description structure example notes bugs/, "symbol type", "source", "author", "copyright", "see also");

unless ( GetOptions ( 
	"verbosedb|dumpdb|d!" => \$dumpdb,
	"verbose|v!" => \$verbose,
	"group|type|g|t=s" => \$specific_only,
	"output|o=s" => \$output_spec,
	"both|b!"    => \$output_both,
	"noentities|noents!" => \$no_autodefs,
	"last-path|last|lp=s" => \$last_path,
)) { die "Error parsing options\n" }

# Determine which stuff to output
my ( $output_list, $output_xml ) = (1,1);
if (!$output_both and $output_spec) {
	$output_spec =~ /\.?list$/ and ($output_list,$output_xml) = (1,0) or
	$output_spec =~ /\.?xml$/  and ($output_list,$output_xml) = (0,1) or
	die "Unknown output combination '$output_spec'\n";
}

$specific_only and $specific_only =~ s/s$//;
@ARGV or die "Usage: $0 version[s]\n";

my %longname = (
	globvar => "Global Variable",
	catvar => "Catalog Variable",
	pragma => "Pragma",
	usertag => "User Tag",
	uitag => "User Interface Tag",
	systemtag => "System Tag",
	globconf => "Global Configuration Directive",
	catconf => "Catalog Configuration Directive",
	filter => "Filter",
);

my %tagname = (
	globvar => "varname",
	catvar => "varname",
	pragma => "pragma",
	usertag => "tag",
	uitag => "tag",
	systemtag => "tag",
	globconf => "option",
	catconf => "option",
	filter => "filter",
);

# Default fields
my %defaults = (
	synopsis => "&DEF_SYNOPSIS;",
	description => "&DEF_DESCRIPTION;",
	example => "&DEF_EXAMPLE;",
	notes => "&DEF_NOTES;",
	bugs => "&DEF_BUGS;",
	source => '&DEF_SOURCE;',
	author => "&DEF_AUTHOR;",
	copyright => "&DEF_COPYRIGHT;",
	'see also' => "&DEF_SEEALSO;",
	purpose => "&DEF_PURPOSE;",
	structure => "&DEF_STRUCTURE;",
);

my @mandatory = (qw/synopsis example description purpose/);

my $path;
my $dumppath;
my $dumpdir;
my @paths = @ARGV;
my $lastpath;

load_templates();

while ( $path = shift @paths) { # For each version specified
	$lastpath = $path;
	$dumppath = $path;
	$i{ver} = $dumppath;
	$dumpdir = "$dumppath/";
	$dumppath .= "/.cache.bin";

	# Load %hash with the cache for particular version (replaces previous one).
	# (which is OK since the data was extraced and we need previous cache
	# no more).
	loaddb( "$cachedir/$dumppath" );

	push @parsed_versions, $hash{version};

	# Outer loop: symbol types (pragmas, globvars, ...)
	# Inner loop: actual symbols
	while ( my ($gkey,$gval) = each %{ $hash{symbols} } ) {
		next if $specific_only and $gkey ne $specific_only;

		# Simply for display purpose
		if (! $symbol_lists{$gkey} ) {
			my @olist;
			push @olist, "refs/${gkey}s.xml" if $output_xml;
			push @olist, "tmp/${gkey}s.list" if $output_list;
			local $" = ", ";
			print "GEN: @olist\n";
		}


		for my $key (keys(%$gval)) {
			my $val = $gval->{$key};

			# Register the symbol name ($key) under group name ($gkey) in
			# %symbol_lists. We need to check if it already exists
			# under %symbol_lists, searching in the same group is not enough
			# because group might have changed in next version (usertag -> uitag).
			# UPDATE: Item can only float between categories if it is a tag,
			# for all other symbols it means we have different symbols of
			# the same name (such as 'value' which is both a tag and filter).
			my $found = 0;

			for my $gk ( keys %symbol_lists ) {
				if ( grep {/^$key$/} @{ $symbol_lists{$gk} } ) {
					if ( $gk ne $gkey ) { # SPLAT! Symbol changed category over time.
						
						# Found non-unique symbol name. (We are not interested in changes
						# from uitag->usertag (or similar), but only in real symbols that
						# are different but have same name). When that happens, 
						# refs/<file> needs to be deleted, and refs/<file>.{gk,gkey}
						# created to uniquely identify items.
						if ( $gkey !~ /tag$/ ) {
							warn "$key IS BOTH $gk and $gkey!\n" if $verbose;
							push @{ $dups{$key} }, $gk, $gkey;
							goto SKIPDUPCHECK;
						}

						# If it was just the same symbol changing tag subgroup
						# (uitag -> usertag), then delete it from the old location.
						# (That means we'll treat it as new item, and it will be properly
						# re-created at the new position).
						my $prev = scalar @{ $symbol_lists{$gk} }; # Quick sanity check
						@{ $symbol_lists{$gk} } = grep {!/^$key$/} @{ $symbol_lists{$gk} };
						my $now = scalar @{ $symbol_lists{$gk} }; # Quick sanity check
						if ( $prev - $now != 1 ) { warn "GREP took out more than 1 item!\n" }
					} else {
						$found++;
						#last; # let's not go into optimizations too early
					}
				}
			}
			SKIPDUPCHECK:
			!$found and push @{ $symbol_lists{$gkey} }, $key;

			# Define basic hash for the item ( $autogenerated{$gkey}{<name>} ), and
			# load values from files. The function returns if
			# $autogenerated{group}{<name>} is present already (that is, the basic
			# skeleton was already made).
			# It is okay to add info from refs/<name>/* to the item at this step
			# because that information is not version-specific; it's constant.
			# ** This fills %autogenerated **
			process_symbol($gkey, $key, $val);

			# Register the presence of this item in this version.
			push @{ $autogenerated{$gkey}{$key}{"_available in"} }, $hash{version};

			# Prepare source contexts, avoiding those cases
			# where a symbol appears multiple times inside the same
			# context lines span, but by stattree it gets counted
			# as a new context. (which is correct technically, but not
			# suitable for display).
			# 
			# Having this code in this loop will make all symbols
			# end up having the last version they appear in displayed in
			# source section.
			my $ag = $autogenerated{$gkey}{$key};
			my $ar = $hash{symbols}{ $$ag{"_symbol type"} }{$key};

			if ( $ar ) {$$ag{source} = "" }

			my $ctxtotal = scalar @$ar;
			my $ctxshown = 0;
			for my $ctx ( @$ar ) {
				
				my $fi = $$ctx{file};
				my $ln = $$ctx{lnum} || 0; #HA! How come $$ctx{lnum} is undefined??
			
				# Support item types with only context info in this field
				for my $arr ( @{ $covered{$key}{$fi} } ) {
					next if !$ln or !$$arr[0] or !$$arr[1];
					if ($ln > $$arr[0] and $ln < $$arr[1]) {
						$ctxtotal--;
						goto DONELOOP;
					}
				}


				# Make sure we don't overdo it with source contexts.
				# MV_PAGE appears on like 31 place. We definitely don't need to
				# see more than 10; let's say 20.
				if ( $ctxshown++ > 20 ) {
					print STDERR "$$ag{name} has ", scalar @$ar,
						" contexts, limiting to $max_ctxs\n" if $verbose;
					goto DONELOOP;
				}

				# We 'shift' here because we unshifted 1 row to match line
				# numbers with array indexes
				my $ctxsdata = join "\n", @{ $$ctx{ctx} };
				#$ctxsdata =~ s/^\n//;
				if ( length $ctxsdata ) {
					my $ls = $$ctx{ctxs}; # line start nr.
					( my $plf = $$ctx{file} ) =~ s#.+?/##;
					$plf =~ /^Vend/ and $plf = "lib/" . $plf; #HA?
					#my $loc = "$$ctx{file}:$$ctx{lnum}";
					my $loc = $$ctx{file};
					
					my ( $cstart, $cend, $ctxmeta ) = ("", "", "");
					my $all = 0; # Showing all for an item?
					#if (0) { use Data::Dumper; print Dumper $ctx; sleep 10; }
					# WE SHOW ONLY PART OF CONTEXT FOR THOSE
					if ( $gkey !~ /(tag|filter)$/ ) {
						$$ctx{ctxpre} ||= 0; $$ctx{ctxpost} ||= 0; # *confs don't have it
						$cstart = $$ctx{lnum}-$$ctx{ctxpre};
						$cend = $cstart+$$ctx{lnum}+$$ctx{ctxpost};

					} else {
						# WE SHOW ALL FOR THOSE
						$all++;
						$cstart = $$ctx{ctxs} || 1;
						$cend = $cstart + scalar @{$$ctx{ctx}}-1;
						$cstart == 1 and $cend -= 1;
					}

					# General fix, shouldn't break anything (Heh, you bet..)
					$cstart <= 0 and $cstart = 1;
					$cend >= $cstart+@{ $$ctx{ctx} } and
						$cend = $cstart+@{ $$ctx{ctx} }-1;

					my $eb = 1; # Include ending bracket?
					if ( ! $all ) {
						$ctxmeta = "<sbr/>Line $ln";
						if ( $cstart == $cend ) {
							$eb = 0;
						} else {
							$ctxmeta .= " (context shows lines " .
								( $cstart . "-" .  $cend );
						}
					} else {
						$ctxmeta = "<sbr/>Lines: $cend";
					}

					if ( $$ctx{funclnum} ) {
						$ctxmeta .= " in $$ctx{func}():$$ctx{funclnum}" ;
					}
					$ctxmeta .= ")" if (!$all and $eb);
					my $r = $hash{revision}{$plf}->[0];
					my $d = $hash{revision}{$plf}->[1];
					my $revinfo = "";
					if ( $gkey !~ /conf$/ ) {
						if ( $r and $d ) {
							$revinfo = "(rev. $r from $d)";
							}
					}


					{ no warnings; # XXX If someone can figure out which of the used vars here is undefined...
					$$ag{source} .= <<ENDD;
<para>
</para>
<figure>
<title>$loc $revinfo$ctxmeta</title>

<screen linenumbering='numbered' startinglinenumber='$ls'>
<![CDATA[$ctxsdata]]>
</screen>
</figure>

ENDD
					}
					$$ag{"source ver"} = $hash{version};
				}
				push @{ $covered{$key}{$fi} }, [ $$ctx{ctxs}, $$ctx{ctxe} ];
				DONELOOP:
			}

			$$ag{"ctxs total"} = $ctxtotal;
			$$ag{"ctxs shown"} = $ctxshown < $max_ctxs ? $ctxshown : $max_ctxs;
		}
	}

	# If this is the last one we want (so, manual break), then stop here.
	# This is for cases where you want to generate docs for say, 5.2.0 and not
	# always cvs-head
	last if $last_path and $last_path eq $path;
}

### THIS IS LAST RUN (Split in multiple loops to avoid chicken-and-egg problem)###
# Final entry. That's where we add examples
# (which don't have version-specific data, they're always "latest")
# FINAL / PASS 1
for my $group ( keys %autogenerated ) {
while ( my($k,$v) = each %{ $autogenerated{$group} } ) {
	my %ag = %$v;

	# Do temporary-only modifications to %ag
	# At the end of the whole block, save completely generated XML to
	# %symbols hash.

	# Double check
	$ag{name} ||= $ag{id} || $k;
	$ag{name} = $hash{specific}{$ag{name}}{_name} if
		$hash{specific}{$ag{name}}{_name};

	################################################################
	# DO STUFF HERE IF IT'S COMMON FOR ALL SYMBOLS. IF it's not,
	# jump out to symbol-specific-subroutine that will handle that.
	################################################################

	# _See Also_ section: "bidirectional" linking
	# Interesting how I actually had this very good idea in the beginning, then I commented
	# it thinking it's crap, and now I'm back to just modifying it a little so it works 
	# as expected again.
	if ( defined @{ $ag{'_see also'} } ) {
		my $list = $ag{'_see also'};
		my %tmp;

		# This loop is now needed since we added the concept of groups in %autogenerated.
		for my $gr ( keys %autogenerated ) {
			$tmp{$_} = $gr for (grep {$autogenerated{$gr}{$_} and $_ ne $ag{name}} @$list);
		}
		@$list =keys %tmp;
		
		for my $sym ( @$list ) {
			my $list2 = $autogenerated{$tmp{$sym}}{$sym}{'_see also'};
			push @$list2, @$list, $k;
			{ my %h; @$list2 = grep {!$h{$_}++ and $sym ne $_} @$list2 }
			@{ $autogenerated{$tmp{$sym}}{$sym}{'_see also'} } = @$list2;
		}
	}
}
}
# FINAL / PASS 2
for my $group ( keys %autogenerated ) {
while ( my($k,$v) = each %{ $autogenerated{$group} } ) {
	my %ag = %$v;

	# Turn 'See Also' items to refentries
	goto END_SEEALSO unless $ag{'_see also'};
	my @see_items = @{ $ag{'_see also'} };
	# XXX only if it's the symbol from same category, otherwise use
	# olink to link between documents
	for my $itm ( @see_items ) {
		next if $itm =~ /^</;
		my $linktype = "link";
		my $linkarg = "linkend";
		if ( $autogenerated{$group}{$itm} ) {
			# This means our item and the target it links to are of same type. So, 
			# nothing, just use default link/linkend=
		} else {
			# If they're not, find appropriate external document to link to
			for my $sect ( keys %symbol_lists ) {
				if ( grep {/^$itm$/} @{ $symbol_lists{$sect} } ) {
					$linktype = "olink";
					$linkarg = "targetdoc='${sect}s' targetptr";
				}
			}
		}
		## Now that $linktype and $linkarg are set, make the link/citerefentry
		$itm or warn "NO ITM???\n";
		$itm =~ s/^(.+)$/<$linktype $linkarg='$1'><citerefentry><refentrytitle>$1<\/refentrytitle><manvolnum>7ic<\/manvolnum><\/citerefentry><\/$linktype>/;
	}
	$ag{'_see also'} = @see_items;
	$ag{'see also'} = join ", ", @see_items;
	END_SEEALSO:

	# Finally, set default values if they weren't overriden by real information
	for my $field (@page_order) {
		if ( ! $ag{$field} ) {
			if ( grep {/$field/} @mandatory) {
				push @{ $invalid{$k} },
					"Missing field '$field', using unsuitable default";
			}
			$ag{$field} = $defaults{$field};
		}
	}


	##########################################################################
	# "Stringify" array values
	$ag{"available in"} = join ", ", @{ $ag{"_available in"} };
	#$ag{'see also'} = join(", \n", $ag{'_see also'}) if
	#	(ref $ag{'_see also'} and scalar @{ $ag{'_see also'}});
	# Compress 4.6.0, 4.8.0, 5.0.0 to 4.6.0-5.0.0
	$ag{'available in'} = compress_availability($ag{'_available in'});


	# DONE
	$ag{latest} = $hash{version};

#	# Visually mark NEW (cvs-head) items
#	if ( @{ $ag{'_available in'} } == 1 and
#		${$ag{'_available in'}}[0] eq $ag{latest} ) {
#		$ag{purpose} = <<ENDD;
#<inlinemediaobject>
#<imageobject>
#<imagedata fileref="./images/new.png" format="PNG"/>
#</imageobject>
#<textdata>
#<phrase>[NEW]</phrase>
#</textdata>
#</inlinemediaobject>
#$ag{purpose}
#ENDD
#	}


	if ( my $fname = $hash{specific}{$ag{name}}{"_tagopt_maproutine"} ) {
		# This means tag is MapRoutined, so it doesn't use any other 
		# symbols directly, but possibly the maproutined function do.
		# So make uses{tag} = uses{maproutined_function}.

		# XXX Should work, but just somehow it doesnt, so comment for now.
		#$hash{uses}{$group}{$ag{name}} = $hash{uses}{function}{ $fname };
	}
	

	# The 'structure' field will show which other symbols the current
	# symbol uses. Fill it:
	if ( $hash{uses}{$group}{$ag{name}} ) {
		$ag{structure} = "<para>This tag appears to be affected by, or affects, the following:</para>\n";
		while (my($k,$v)=each %{ $hash{uses}{$group}{$ag{name}} }) {
			s/^(.+)$/<$tagname{lc $k}>$1<\/$tagname{lc $k}>/ for @$v;
			local $" = ", ";
			$k = $longname{$k};
			$ag{structure} .= "${k}s: @$v<sbr/>\n";
		}
	} else {
		$ag{structure} = "<para>This tag does not appear to be affected by, or affect, the rest of Interchange.</para>\n";
	}


	# Expand template
	my $template = $templates{ $ag{"_symbol type"} };
	$template or warn "No template $ag{'_symbol type'} ?\n";

	{ no warnings;
	# I simply hate this, I can't find out which field
	# is undefined
	while ( $template =~ s/(\$ag{.*?})/$1/eem ) {};
	}

	# Save
	$symbols{$group}{$k} =
		$template unless ( $ag{ignore} and $ag{ignore} =~ /[y1d]/i );
}
}

# Produce reference sets (docbook element Reference contains RefEntries)
for my $group ( keys %symbols ) {
	# Prepare reference page

	my $refpage = <<ENDD;
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook-Interchange XML V4.2//EN"
	"../docbook/docbookxi.dtd">

<reference id="${group}s">
	<title>Interchange Reference Pages: $longname{$group}s</title>
ENDD

	## Add items
	for my $key (sort keys %{ $symbols{$group} }) {
		$refpage .= $symbols{$group}{$key}
	}

	## Close up
	$refpage .= "\n" . '</reference>';

	# Dump page
	open OUT, "> refs/${group}s.xml" or
		die "Can't produce reference refs/{$group}s.xml ($!)\n";
	print OUT $refpage;
	close OUT;
#}
}


# Output lists
if ( $output_list ) {
	my @syms = $specific_only ? ($specific_only) : keys %symbol_lists;
	local $" = "\n";
	for my $sym (@syms) {
		my @list = sort @{ $symbol_lists{$sym} };
		open OUT, "> tmp/${sym}s.list" or die "Can't open tmp/${sym}s.list ($!)\n";
		print OUT "@list";
		close OUT;
	}
}

# Output the 'invalid' list
$invalid{$_} = ("Missing all (undocumented)") for @set_missing_all;
open INVOUT, "> tmp/missing" or
	die "Can't open tmp/missing ($!)\n";
print INVOUT Dumper \%invalid;
close INVOUT;

# Output autodefs.ent
unless ( $no_autodefs ) {
	open ATD, "> $autopath" or die "Can't wropen $autopath ($!)\n";
	print "GEN: $autopath\n";

	while (my($g,$kr) = each %symbol_lists) {
		for $_ (@$kr) {
			my $tag;

			if ( $g =~ /tag$/ ) {
				$tag = 'tag';
			} elsif ( $g =~ /pragma$/ ) {
				$tag = 'pragma';
			} elsif ( $g =~ /var$/ ) {
				$tag = 'varname';
			} elsif ( $g =~ /conf$/ ) {
				$tag = 'option';
			} elsif ( $g =~ /filter$/ ) {
				$tag = 'filter';
			} else {
				die "UNKNOWN $g\n";
			}

			( my $prefix = $g ) =~ s/.+(tag|conf|var)$/$1/;

#<!ENTITY $_ "<olink targetdoc='${g}s' targetptr='$_'>$_</olink>">
			print ATD <<ENDD;
<!ENTITY ${prefix}-$_ "<$tag>$_</$tag>">
ENDD
		}
	}

	close ATD;
}

# Boy, did I previously misplace this critical code...
if ( $dumpdb ) { print STDERR Dumper \%autogenerated; exit 0; }

exit 0;

#################################################################
# Helpers below

sub process_symbol {
	my ($group, $name, $ref) = @_;

	# XXX: Ok, now, I figured this thing out. Some files changed location
	# between versions and their type changed, so this fell apart.
	# ( for example, usertag moved to uitag ).
	# To fix this, we simply leave item skeleton to be autoregenerated in
	# those cases (we could leave through in any case, but that would waste
	# time).

	# Move some of this to the above code that calls process_symbol() ?
	# Or, what the f* was I thinking when I disabled this region?
	if ( ref $autogenerated{$group}{$name} ) { # Symbol known
		if ( $autogenerated{$group}{$name}{"_symbol type"} ne $group ) { # But changed grp.
			# The good entry is already in symbol_lists (done in wanted()), we
			# only need to remove this invalid one here.
			@{$symbol_lists{$group} } = grep{!/^$name$/} @{ $symbol_lists{$group}};
			# XXX In a new system, add file pathname change to NOTES section.
			# And correct the field (we can't simply let through to regenerate
			# the skeleton because that would delete previous "available in"
			# information):
			$autogenerated{$group}{$name}{"_symbol type"} = $group;
			$autogenerated{$group}{$name}{"symbol type"} = "&SYMBOL_" . uc($group) . ";",
		}
		return
	}

	# Make skel
	$autogenerated{$group}{$name} = {
		name => $name,
		id => $name,
		"_symbol type" => $group,
		"symbol type" => "&SYMBOL_" . uc($group) . ";",
	};

	# Suplement with information from a control file
	populate($autogenerated{$group}{$name}, $group, $name, 'control', 'override');
	populate($autogenerated{$group}{$name}, $group, $name, '', 'append');
}

# XXX support reading from refs/<name> file.
sub populate {
	my ($ref, $group, $name, $file, $mode) = @_;

	my $fgroup = $group; $fgroup =~ /tag$/ and $fgroup = 'tag';
	my $specpath = "refs/$name.$fgroup";  # Specific path
	my $genpath = "refs/$name";          # Generic path (no type visible in it)
	my $refpath = -e $specpath ? $specpath : $genpath; # USE THIS FOR PATHNAME

	# If symbol name is not unique, then explicit type must be specified.
	# (That is, the 'value' symbols needs to have refs/value.tag and
	# refs/value.filter);
	# Config directives (globconfs/catconfs) can have one file (refs/<name>)
	# to document both symbols at once.
	if (
		$dups{$name} and     # Symbol name is non-unique
		-e $genpath and      # Generic file exists (refs/<name>)
		!-e $specpath and    # But special files don't (refs/<name>.<group>)
		$group !~ /conf|var$/ ) {# And it's not a cfg directive or globvar/catvar
		                         #for which we tolerate
		local $" = " AND ";
		die "Symbol '$name' is: @{ $dups{$name} }. Must have refs/<name>.<type>\n";
	}

	# From one specific file (control file usually)
	if ( $file ) {
		open IN, "< $refpath/$file" or do {
			push @{ $invalid{$name} }, "Requested file '$file' ($!)";
			return;
		};
		if ( $file eq 'control' ) {
			while (my $line = <IN>) {
				next if $line =~ /^\s*#/;
				chomp $line;
				$line =~ s/^\s+//;
				my ($sect,$text) = split /\s*:\s*/, $line, 2;
				update_field($mode, $group, $name, $ref, $file, $sect, $text)
					if ( defined $text and length $text );
			}
		} else {
			die "TODO: Reading from non-control files not supported.\n";
		}
		close IN;

	# From other file sets
	} elsif (! length $file) { # all files

		if ( -d "$refpath" ) {
			opendir INDIR, "$refpath/" or do {
				warn "Can't open $refpath/ ($!)\n";
				return
			};
			while (my $fn = readdir INDIR) {
				next if $fn =~ /^\.|^CVS$/;
				next if $fn eq 'control';
				open INF, "< $refpath/$fn" or
					die "Can't open $refpath/$fn ($!)\n";

				my $sect = $fn;

				my $content = join "", <INF>;
				close INF;

				update_field ("append", $group, $name, $ref, $fn, $sect, $content);
			}
			closedir INDIR;

		} elsif ( -f "$refpath" ) {
			open IN, "< $refpath" or do {
				warn "Can't open $refpath ($!)\n";
				return
			};
			my @c = <IN>;
			close IN;

			my ( $section, $content );
			# XXX check if it's empty, then don't update
			for my $line (@c) {
				if ( $line =~ /^__NAME__ (.+)\s*$/ ) { $section = $1; next }
				if ( $line =~ /^__END__/ ) {
					update_field("append", $group, $name, $ref, "$refpath", $section, $content);
					$section = "";
					$content = "";
				}

				# Update record
				$content .= $line if $section;
			}

		} else {
			push @set_missing_all, $name;
		}

	} else {
		die "Parsing of specific, non-control files not implemented\n";
	}
}

sub update_field {
	my ($mode, $group, $name, $sref, $fn, $sect, $content) = @_;

	$sect =~ s/[\-\.\+_:\d].*//;
	$sect =~ s/([a-z])([A-Z])/$1 $2/g;
	$sect = lc $sect;

	if ( $sect ne 'missing' ) {

		if (!( grep {/^$sect/} @page_order )) {
			push @{ $invalid{$name} }, "Section '$sect' from file '$fn' won't be used (name not recognized)";
		}

		if ( $mode eq 'override' ) {
			$$sref{lc $sect} = $content;
		} else {
			# Causes problems
			#$$sref{lc $sect} .= $$sref{lc $sect} ?
			#	'</para><para>' . $content : $content;
			$$sref{lc $sect} .= $content if $content;
		}
		if ( $sect =~ /^see also$/i ) {
			( my $list = $content ) =~ s/,/ /g;
			my @list = split /\s+/, $list;
			@{ $$sref{'_see also'} } = @list;
		}

	} else { # "Missing" section
		my @missing_list = split /\n/, $content;
		push @{ $invalid{$name} }, $_ for @missing_list
	}
}

sub loaddb {
	my $dbpath = shift;

	unless ( exists $refcache{$dbpath} ) {
		open( IN, "< $dbpath") or
			die "Can't open database ($dbpath) ($!).\n";
		flock( IN, LOCK_SH ) or
			die "Can't shared-lock database ($dbpath) ($!).\n";
		$refcache{$dbpath} = fd_retrieve( \*IN );
		close IN or
			die "Can't properly close database ($dbpath) ($!).\n";
	}

	%hash = %{ $refcache{$dbpath} };
}

sub compress_availability {
	my @avails = my @orig = @{ (shift) };
	@avails or die "compress_availability(): Shouldn't happen";

	# XXX this needs work, but at the moment it serves us well
	# (it can't handle like x-y, z, a-b. It only handles start-end)

	my $start = shift @avails;
	my $si; # starting index
	my $cl = 0; # compress level
	for (my $i=0; $i<@parsed_versions;$i++) {
		if ( $parsed_versions[$i] eq $start ) {
			$si = $i;
		}
	}
	my $end;
	while ( $_ = shift @avails ) {
		if ( $parsed_versions[++$si] eq $_ ) {
			$end = $_;
			$cl++;
		} else {
			unshift @avails, $_;
			last
		}
	}
	local $" = ", ";
	if ( $cl > 1 ) {
		unshift @avails, "$start-$end";
		return "@avails"
	} else {
		return "@orig"
	}
}

sub O { print "@_\n"; print STDOUT "@_\n" if $verbose }


#
# TEMPLATES, SYMBOL-SPECIFIC
#
#
#<refsect1 id='$ag{"name"}_online' condition='online'>
#<title>ONLINE EXAMPLES</title>
#$ag{"online"}
#</refsect1>

sub load_templates {


$templates{pragma} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>VALUE</title>
<cmdsynopsis>
$ag{"synopsis"}
</cmdsynopsis>
</refsect1>

<refsect1 id='$ag{"name"}_default'>
<title>DEFAULT</title>
<para>$ag{"default"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"} ($ag{"ctxs shown"}/$ag{"ctxs total"} contexts shown):</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{filter} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{usertag} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>PARAMETERS</title>

<informaltable pgwide='1' frame='none'>
<tgroup cols='5' align='left'>
<colspec colname='arg'/>
<colspec colname='pos'/>
<colspec colname='req'/>
<colspec colname='def'/>
<colspec colname='dsc'/>

<thead>
<row>
<entry>Argument</entry>
<entry>Pos.</entry>
<entry>Req.</entry>
<entry>Default</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
$ag{"synopsis"}
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_structure"}'>
<title>BEHAVIOR</title>
<para>$ag{"structure"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{globconf} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>SYNOPSIS</title>
<cmdsynopsis>
$ag{"synopsis"}
</cmdsynopsis>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__

$templates{globvar} = $templates{pragma};
$templates{catvar} = $templates{pragma};
$templates{uitag} = $templates{usertag};
$templates{systemtag} = $templates{usertag};
$templates{catconf} = $templates{globconf};

}

