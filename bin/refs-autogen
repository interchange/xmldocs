#! /usr/bin/perl

# docelic@icdevgroup.org

# The script parses cache files made by bin/stattree, and generates
# the refs/*.xml files.
# Currently that includes pragmas, globvars, uitags, usertags, systemtags.

# Ok, so this is how the .xml generation process goes:
#
# - We first load all templates to $templates{sybol_name}. Each symbol type
#   has its own template (which are specified at the end of this file).
#
# - Then for each IC version mentioned on the command line, we:
#   - load the cache file
#   - go through all the symbols found in the cache, and:
#     - push symbol name to @$symbol_lists{group name} (if not there already)
#     - call process_symbol() which creates the skel entry in
#       $autogenerated{$symbol} if not present (and also fixes stuff if the
#       item IS present, but the path changed so Source contexts wouldn't work).
#     - we then call populate() which updates $autogenerated{$symbol} with
#       user-supplied information from the filesystem (refs/*/*).
#     - we update the "Available in" line
#     - we do some more tuning
#     - we construct the "Source" section (only dealing with formatting
#       and display; what's actually in there is already decided in 
#       bin/stattree run)
#     -
use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

{ no warnings;
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;
}

my $force_regenerate = 1; # Rebuild pages even if they exist
my $dumpdb = 0;
my $verbose = 0;
my $OUTPUT = "OUTPUT";
my %refcache; # memory cache of Storable files. Not really needed but I 
              # copied old code which had it, so ...
my %hash; # complete tree data
my $cachedir = $ENV{CACHE} || "cache";
my %i; # internally derived data
my %autogenerated; # Data for symbols autogenerated in this run
my %invalid; # Information about missing documentation
my %covered; # Weed out duplicate context reports
my %symbol_lists; # symbols listed in categories
my %symbols; # FINAL symbol refentries
my %templates;
my $max_ctxs = 10;
my @set_missing_all;
my @parsed_versions;

my @page_order = (qw/purpose default structure synopsis description example notes bugs/, "symbol type", "source", "author", "copyright", "see also");

unless ( GetOptions ( 
	"verbosedb|dumpdb|d!" => \$dumpdb,
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV or die "Usage: $0 version[s]\n";

my %longname = (
	globvar => "Global Variable",
	pragma => "Pragma",
	usertag => "User Tag",
	uitag => "User Interface Tag",
	systemtag => "System Tag",
);

# Default fields
my %defaults = (
	synopsis => "&DEF_SYNOPSIS;",
	description => "&DEF_DESCRIPTION;",
	example => "&DEF_EXAMPLE;",
	notes => "&DEF_NOTES;",
	bugs => "&DEF_BUGS;",
	source => '&DEF_SOURCE;',
	author => "&DEF_AUTHOR;",
	copyright => "&DEF_COPYRIGHT;",
	'see also' => "&DEF_SEEALSO;",
	purpose => "&DEF_PURPOSE;",
);

my @mandatory = (qw/synopsis example description purpose/);

my $path;
my $dumppath;
my $dumpdir;
my @paths = @ARGV;
my $lastpath;

load_templates();

while ( $path = shift @paths) { # For each version specified
	$lastpath = $path;
	$dumppath = $path;
	$i{ver} = $dumppath;
	$dumpdir = "$dumppath/";
	$dumppath .= "/.cache.bin";

	# Load %hash with the cache for particular version (replaces previous one).
	# (which is OK since the data was extraced and we need previous cache
	# no more).
	loaddb( "$cachedir/$dumppath" );

	push @parsed_versions, $hash{version};

	# Outer loop: symbol types (pragmas, globvars, ...)
	# Inner loop: actual symbols
	while ( my ($gkey,$gval) = each %{ $hash{symbols} } ) {
		for my $key (keys(%$gval)) {
			my $val = $gval->{$key};

			# Register the symbol name ($key) under group name ($gkey) in
			# %symbol_lists.
			push @{ $symbol_lists{$gkey} }, $key
				unless grep {/^$key$/} @{ $symbol_lists{$gkey} };

			# Define basic hash for the item ( $autogenerated{<name>} ), and
			# load values from files. The function returns if
			# $autogenerated{<name>} is present already (that is, the basic
			# skeleton was already made).
			# It is okay to add info from refs/<name>/* to the item at this step
			# because that information is not version-specific; it's constant.
			# ** This fills %autogenerated **
			process_symbol($gkey, $key, $val);

			# Register the presence of this item in this version.
			push @{ $autogenerated{$key}{"_available in"} }, $hash{version};
			$autogenerated{$key}{"available in"} =
				join ", ", @{ $autogenerated{$key}{"_available in"} };

			# Prepare source contexts, avoiding those cases
			# where a symbol appears multiple times inside the same
			# context lines span, but by stattree it gets counted
			# as a new context. (which is correct technically, but not
			# suitable for display).
			# 
			# Having this code in this loop will make all symbols
			# end up having the last version they appear in displayed in
			# source section.
			my $ag = $autogenerated{$key};
			my $ar = $hash{symbols}{ $$ag{"_symbol type"} }{$key};

			if ( $ar ) {$$ag{source} = "" }

			$$ag{"ctxs total"} = scalar @$ar;
			$$ag{"ctxs shown"} = @$ar < $max_ctxs ? @$ar : $max_ctxs;

			my $ctxcount = 0;
			for my $ctx ( @$ar ) {
				
				# Make sure we don't overdo it with source contexts.
				# MV_PAGE appears on like 31 place. We definitely don't need to
				# see more than 10.
				if ( $ctxcount++ > $max_ctxs ) {
					print STDERR "$$ag{name} has ", scalar @$ar,
						" contexts, limiting to $max_ctxs\n";
					last;
				}
#					my $hidden = @$ar - $max_ctxs;
#					$$ag{source} .= <<ENDD;
#<para>
#</para>
#<para>
#(With $hidden contexts not shown).
#</para>
#ENDD

				my $fi = $$ctx{file};
				my $ln = $$ctx{lnum};
			
				# Support item types with only context info in this field
				for my $arr ( @{ $covered{$key}{$fi} } ) {
					goto DONELOOP if $ln > $$arr[0] and $ln < $$arr[1];
				}
				my $ctxsdata = join "\n", @{ $$ctx{ctx} };
				if ( length $ctxsdata ) {
					my $ls = $$ctx{ctxs}; # line start nr.
					( my $plf = $$ctx{file} ) =~ s#.+?/##;
					#my $loc = "$$ctx{file}:$$ctx{lnum}";
					my $loc = $$ctx{file};
					
					my $cstart = $$ctx{lnum}-$$ctx{ctxpre};
					# XXX - eliminate negative numbers in source context spans
					# ( 0-6 == OK, -4-6 != OK )
					#if ( $cstart < 0 ) {
					#	print STDERR "CSTART IS $cstart FOR $$ag{name}\n";
					#	$cstart = 0 ;
					#}
					my $cend = $$ctx{lnum}+$$ctx{ctxpost};
					my $ctxmeta = "Line $$ctx{lnum} (context shows lines " .
						( $cstart . "-" .  $cend );
					
					$ctxmeta .= " in $$ctx{func}():$$ctx{funclnum}" if $$ctx{funclnum};
					$ctxmeta .= ")";
					my $r = $hash{revision}{$plf}->[0];
					my $d = $hash{revision}{$plf}->[1];
# XXX when xsltproc gets to support line numbering, add this below:
#<screen linenumbering='numbered' startinglinenumber='$ls'><![CDATA[
					$$ag{source} .= <<ENDD;
<para>
</para>
<example>
<title>$loc (rev. $r from $d)<sbr/>$ctxmeta</title>

<screen><![CDATA[
$ctxsdata
]]></screen>
</example>

ENDD
					$$ag{"source ver"} = $hash{version};
				}
				push @{ $covered{$key}{$fi} }, [ $$ctx{ctxs}, $$ctx{ctxe} ];
				DONELOOP:
			}
		}
	}
}

### THIS IS LAST RUN ###
# Final entry. That's where we add examples
# (which don't have version-specific data, they're always "latest")
while ( my($k,$v) = each %autogenerated ) {
	my %ag = %$v;

	# Do temporary-only modifications to %ag
	# At the end of the whole block, save completely generated XML to
	# %symbols hash.

	# Double check
	$ag{name} ||= $ag{id} || $k;
	$ag{name} = $hash{specific}{$ag{name}}{_name} if
		$hash{specific}{$ag{name}}{_name};

	################################################################
	# DO STUFF HERE IF IT'S COMMON FOR ALL SYMBOLS. IF it's not,
	# jump out to symbol-specific-subroutine that will handle that.
	################################################################

	# PLUG IN SYMBOL-SPECIFIC STUFF HERE
	
	## If we're dealing with a TAG, construct its "Default" section:
	#if ( $ag{"_symbol type"} =~ /tag$/i and !$ag{default} ) {
	#	my @items;
	#	while ( my ($x,$y) = each %{ $hash{specific}{ $ag{name} } } ) {
	#		next unless $x =~ s/^_tagopt_//;
	#		push @items, "$x $y";
	#	}
	#	#$ag{default} = join '</para><para>', @items;
	#	$ag{default} = join '<sbr/>', @items;
	#}

	# _See Also_ section: "bidirectional" linking
	if ( defined @{ $ag{'_see also'} } ) {
		my $list = $ag{'_see also'};
		@$list = grep {$autogenerated{$_} and $_ ne $ag{name}} @$list;
		#$ag{'see also'} = join ", ", @{ $ag{'_see also'} }; # Done below anyway
		
		for my $sym ( @$list ) {
			my $list2 = $autogenerated{$sym}{'_see also'};
			push @$list2, @$list, $k;
			{ my %h; @$list2 = grep {!$h{$_}++ and $sym ne $_} @$list2 }
			@{ $autogenerated{$sym}{'_see also'} } = @$list2;
			$autogenerated{$sym}{'see also'} = join ", ", @$list2;
		}
	}

	# Turn 'See Also' items to refentries
	my @see_items = @{ $ag{'_see also'} };
	# XXX only if it's the symbol from same category, otherwise use
	# olink to link between documents
	for my $itm ( @see_items ) {
		if ( $autogenerated{$itm} ) {
			my $linktype = "link"; # the default, linking inside the same document
			my $linkarg = "linkend";
			if ( $autogenerated{$itm}{'_symbol type'} eq $ag{'_symbol type'} ) {
				# Nothing, just use link linkend= if the targets are inside the same
				# document.
			} else {
				# If they're not, find appropriate external document to link to
				for my $sect ( keys %symbol_lists ) {
					if ( grep {/^$itm$/} @{ $symbol_lists{$sect} } ) {
						$linktype = "olink";
						$linkarg = "targetdoc='${sect}s' targetptr";
					}
				}
			}
			# Now that $linktype and $linkarg are set, make the link/citerefentry
			$itm =~ s/^(.+)$/<$linktype $linkarg='$1'><citerefentry><refentrytitle>$1<\/refentrytitle><manvolnum>7ic<\/manvolnum><\/citerefentry><\/$linktype>/;
		}
	}
	$ag{'see also'} = join ", ", @see_items;

	# Compress 4.6.0, 4.8.0, 5.0.0 to 4.6.0-5.0.0
	$ag{'available in'} = compress_availability($ag{'_available in'});

	# Finally, set default values if they weren't overriden by real information
	for my $field (@page_order) {
		if ( ! $ag{$field} ) {
			if ( grep {/$field/} @mandatory) {
				push @{ $invalid{$k} },
					"Missing field '$field', using unsuitable default";
			}
			$ag{$field} = $defaults{$field};
		}
	}


	# DONE
	$ag{latest} = $hash{version};

	# Expand template
	my $template = $templates{ $ag{"_symbol type"} };
	$template or warn "No template $ag{'_symbol type'} ?\n";

	{ no warnings;
	# I simply hate this, I can't find out which field
	# is undefined
	while ( $template =~ s/(\$ag{.*?})/$1/eem ) {};
	}

	# Save
	$symbols{$k} = $template unless ( $ag{ignore} and $ag{ignore} =~ /[y1d]/i );
}

sub compress_availability {
	my @avails = my @orig = @{ (shift) };
	@avails or die "compress_availability(): Shouldn't happen";

	# XXX this needs work, but at the moment it serves us well
	# (it can't handle like x-y, z, a-b. It only handles start-end)

	my $start = shift @avails;
	my $si; # starting index
	my $cl = 0; # compress level
	for (my $i=0; $i<@parsed_versions;$i++) {
		if ( $parsed_versions[$i] eq $start ) {
			$si = $i;
		}
	}
	my $end;
	while ( $_ = shift @avails ) {
		if ( $parsed_versions[++$si] eq $_ ) {
			$end = $_;
			$cl++;
		} else {
			unshift @avails, $_;
			last
		}
	}
	local $" = ", ";
	if ( $cl > 2 ) {
		unshift @avails, "$start-$end";
		return "@avails"
	} else {
		return "@orig"
	}
}


# Produce reference sets (docbook element Reference contains RefEntries)
while (my ($k,$v) = each %symbol_lists ) {
	# Prepare reference page

	my $refpage = <<ENDD;
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook-Interchange XML V4.2//EN"
	"../docbook/docbookxi.dtd">

<reference id="${k}s">
	<title>Interchange Reference Pages: $longname{$k}s</title>
ENDD

	## Add items
	for my $item (sort @$v) {
		$refpage .= $symbols{$item} if $symbols{$item}
	}

	## Close up
	$refpage .= "\n" . '</reference>';

	# Dump page
	open OUT, "> refs/${k}s.xml" or
		die "Can't produce reference refs/$k.xml ($!)\n";
	print OUT $refpage;
	close OUT;
}

# Output the 'invalid' list
$invalid{$_} = ("Missing all (undocumented)") for @set_missing_all;
open INVOUT, "> tmp/missing" or
	die "Can't open tmp/missing ($!)\n";
print INVOUT Dumper \%invalid;
close INVOUT;

exit 0;

#################################################################
# Helpers below

sub process_symbol {
	my ($group, $name, $ref) = @_;

	# XXX: Ok, now, I figured this thing out. Some files changed location
	# between versions and their type changed, so this fell apart.
	# ( for example, usertag moved to uitag ).
	# To fix this, we simply leave item skeleton to be autoregenerated in
	# those cases (we could leave through in any case, but that would waste
	# time).
	if ( ref $autogenerated{$name} ) {
		if ( $autogenerated{$name}{"_symbol type"} ne $group ) {
			# The good entry is already in symbol_lists (done in wanted()), we
			# only need to remove this invalid one here.
			@{$symbol_lists{$group} } = grep{!/^$name$/} @{ $symbol_lists{$group}};

			# XXX In a new system, add file pathname change to NOTES section.

			# And correct the field (we can't simply let through to regenerate
			# the skeleton because that would delete previous "available in"
			# information):
			$autogenerated{$name}{"_symbol type"} = $group;
			$autogenerated{$name}{"symbol type"} = "&SYMBOL_" . uc($group) . ";",
		}
		return
	}

	# Make skel
	$autogenerated{$name} = {
		name => $name,
		id => $name,
		"_symbol type" => $group,
		"symbol type" => "&SYMBOL_" . uc($group) . ";",
	};

	# Suplement with information from a control file
	populate($autogenerated{$name}, $name, 'control', 'override');
	populate($autogenerated{$name}, $name, '', 'append');
}

# XXX support reading from refs/<name> file.
sub populate {
	my ($ref, $name, $file, $mode) = @_;

	# From one specific file (control file usually)
	if ( $file ) {
		open IN, "< refs/$name/$file" or do {
			push @{ $invalid{$name} }, "Requested file '$file' ($!)"
				unless -f "refs/$name";
			return;
		};
		if ( $file eq 'control' ) {
			while (my $line = <IN>) {
				next if $line =~ /^\s*#/;
				chomp $line;
				$line =~ s/^\s+//;
				my ($sect,$text) = split /\s*:\s*/, $line, 2;
				update_field($mode, $name, $ref, $file, $sect, $text)
					if ( defined $text and length $text );
			}
		}
		close IN;

	# From other file sets
	} elsif (! length $file) { # all files

		if ( -d "refs/$name" ) {
			opendir INDIR, "refs/$name/" or do {
				warn "Can't open refs/$name/ ($!)\n";
				return
			};
			while (my $fn = readdir INDIR) {
				next if $fn =~ /^\.|^CVS$/;
				next if $fn eq 'control';
				open INF, "< refs/$name/$fn" or
					die "Can't open refs/$name/$fn ($!)\n";

				my $sect = $fn;

				my $content = join "", <INF>;
				close INF;

				update_field ("append", $name, $ref, $fn, $sect, $content);
			}
			closedir INDIR;

		} elsif ( -f "refs/$name" ) {
			open IN, "< refs/$name" or do {
				warn "Can't open refs/$name ($!)\n";
				return
			};
			my @c = <IN>;
			close IN;

			my ( $section, $content );
			# XXX check if it's empty, then don't update
			for my $line (@c) {
				if ( $line =~ /^__NAME__ (.+)\s*$/ ) { $section = $1; next }
				if ( $line =~ /^__END__/ ) {
					update_field("append", $name, $ref, "refs/$name", $section, $content);
					$section = "";
					$content = "";
				}

				# Update record
				$content .= $line if $section;
			}

		} else {
			push @set_missing_all, $name;
		}

	} else {
		die "Parsing of specific, non-control files not implemented\n";
	}
}

sub update_field {
	my ($mode, $name, $sref, $fn, $sect, $content) = @_;

	$sect =~ s/[\-\.\+_:\d].*//;
	$sect =~ s/([a-z])([A-Z])/$1 $2/g;
	$sect = lc $sect;

	if (!( grep {/^$sect/} @page_order )) {
		push @{ $invalid{$name} }, "Section '$sect' from file '$fn' won't be used (name not recognized)";
	}

	if ( $sect ne 'missing' ) {
		if ( $mode eq 'override' ) {
			$$sref{lc $sect} = $content;
		} else {
			# Causes problems
			#$$sref{lc $sect} .= $$sref{lc $sect} ?
			#	'</para><para>' . $content : $content;
			$$sref{lc $sect} .= $content;
		}
		if ( $sect =~ /^see also$/i ) {
			( my $list = $content ) =~ s/,/ /g;
			my @list = split /\s+/, $list;
			push @{ $$sref{'_see also'} }, @list;
			$$sref{'see also'} = join ", ", @{$$sref{'_see also'}};
		}
	}

	# Older code
	#if ( $mode eq 'override' ) {
	#	$$sref{$sect} = $content;
	#} elsif ( $mode eq 'append' ) {
	#	$$sref{$sect} .= $content;
	#}
}

sub loaddb {
	my $dbpath = shift;

	unless ( exists $refcache{$dbpath} ) {
		open( IN, "< $dbpath") or
			die "Can't open database ($dbpath) ($!).\n";
		flock( IN, LOCK_SH ) or
			die "Can't shared-lock database ($dbpath) ($!).\n";
		$refcache{$dbpath} = fd_retrieve( \*IN );
		close IN or
			die "Can't properly close database ($dbpath) ($!).\n";
	}

	%hash = %{ $refcache{$dbpath} };

	if ( $dumpdb ) {
		print STDERR Dumper \%hash;
		exit 0;
	}
}

sub O { print "@_\n"; print STDOUT "@_\n" if $verbose }


#
# TEMPLATES, SYMBOL-SPECIFIC
#

sub load_templates {


$templates{pragma} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>VALUE</title>
<cmdsynopsis>
$ag{"synopsis"}
</cmdsynopsis>
</refsect1>

<refsect1 id='$ag{"name"}_default'>
<title>DEFAULT</title>
<para>$ag{"default"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"} ($ag{"ctxs shown"}/$ag{"ctxs total"} contexts shown):</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<!-- Removed because copyright is seen in Source (first few lines),
     and the generated document starts with copyright notice
<refsect1 id='$ag{"name"}_copyright'>
<title>COPYRIGHT</title>
$ag{"copyright"}
</refsect1>
-->

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{usertag} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>PARAMETERS</title>

<informaltable pgwide='1' frame='none'>
<tgroup cols='5' align='left'>
<colspec colname='arg'/>
<colspec colname='pos'/>
<colspec colname='req'/>
<colspec colname='def'/>
<colspec colname='dsc'/>

<thead>
<row>
<entry>Argument</entry>
<entry>Pos.</entry>
<entry>Req.</entry>
<entry>Default</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
$ag{"synopsis"}
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<!-- Disabled. I could remove it unless I do something useful with it.
<refsect1 id='$ag{"name"}_structure"}'>
<title>TAG STRUCTURE</title>
<para>$ag{"structure"}</para>
</refsect1>
-->

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<!-- Removed because copyright is seen in Source (first few lines),
     and the generated document starts with copyright notice
<refsect1 id='$ag{"name"}_copyright'>
<title>COPYRIGHT</title>
$ag{"copyright"}
</refsect1>
-->

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__

$templates{globvar} = $templates{pragma};
$templates{uitag} = $templates{usertag};
$templates{systemtag} = $templates{usertag};

}

