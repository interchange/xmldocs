#! /usr/bin/perl

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

{ no warnings;
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;
}

my $force_regenerate = 1; # Rebuild pages even if they exist
my $dumpdb = 0;
my $verbose = 0;
my $OUTPUT = "OUTPUT";
my %refcache; # memory cache of Storable files. Not really needed but I 
              # copied old code which had it, so ...
my %hash; # complete tree data
my $cachedir = $ENV{CACHE} || "cache";
my %i; # internally derived data
my %autogenerated; # Data for symbols autogenerated in this run
my %invalid; # Information about missing documentation
my %covered; # Weed out duplicate context reports
my %symbol_lists; # symbols listed in categories
my %symbols; # FINAL symbol refentries
my @template = <DATA>;

my @page_order = (qw/purpose synopsis description example notes bugs/, "symbol type", "source", "author", "copyright", "see also");

unless ( GetOptions ( 
	"verbosedb|dumpdb|d!" => \$dumpdb,
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV or die "Usage: $0 version[s]\n";

my %longname = (
	globvar => "Global Variable",
	pragma => "Pragma",
	usertag => "User Tag",
	uitag => "User Interface Tag",
	systemtag => "System Tag",
);

# General description of symbol types
# Move to docbook/docbookxi.dtd entities
my %general_desc;
opendir DIR, "docbook/symbol-type-skel";
while ( my $file = readdir DIR ) {
	next if $file =~ /^\.|^CVS$/;
	open INF, "< docbook/symbol-type-skel/$file" or
		die "Can't open docbook/symbol-type-skel/$file ($!)\n";
	$general_desc{$file} = join "", <INF>;
	close INF;
}
closedir DIR;

# Default fields
my %defaults = (
	synopsis => "&DEF_SYNOPSIS;",
	description => "&DEF_DESCRIPTION;",
	example => "&DEF_EXAMPLE;",
	notes => "&DEF_NOTES;",
	bugs => "&DEF_BUGS;",
	'symbol type' => "&DEF_SYMBOLTYPE;",
	source => '&DEF_SOURCE;',
	author => "&DEF_AUTHOR;",
	copyright => "&DEF_COPYRIGHT;",
	'see also' => "&DEF_SEEALSO;",
	purpose => "&DEF_PURPOSE;",
);

my @mandatory = (qw/synopsis example description purpose/, "symbol type");


my $path;
my $dumppath;
my $dumpdir;
my @paths = @ARGV;
my $lastpath;

while ( $path = shift @paths) {
	$lastpath = $path;
	$dumppath = $path;
	$i{ver} = $dumppath;
	$dumpdir = "$dumppath/";
	$dumppath .= "/.cache.bin";

	# Load DB
	loaddb( "$cachedir/$dumppath" );

	# This fills %autogenerated
	# Outer loop: symbol types (pragmas, globvars, ...)
	# Inner loop: actual symbols
	while ( my ($gkey,$gval) = each %{ $hash{symbols} } ) {
		# Let's include tags now, disable the skip
		#next unless $gkey =~ /^(globvar|pragma)$/;
		for my $key (keys(%$gval)) {
			my $val = $gval->{$key};
			push @{ $symbol_lists{$gkey} }, $key
				unless grep {/^$key$/} @{ $symbol_lists{$gkey} };
			process_symbol($gkey, $key, $val);
			push @{ $autogenerated{$key}{"_available in"} }, $hash{version};
			$autogenerated{$key}{"available in"} =
				join ", ", @{ $autogenerated{$key}{"_available in"} };

			# Prepare source contexts, avoiding those cases
			# where a symbol appears multiple times inside the same
			# context lines span, but by stattree it gets counted
			# as a new context. (which is correct technically, but not
			# suitable for display).
			# 
			# Having this code in this loop will make all symbols
			# end up having the last version they appear in displayed in
			# source section.
			my $ag = $autogenerated{$key};
			my $ar = $hash{symbols}{ $$ag{"_symbol type"} }{$key};
			if ( $ar and @$ar ) { $$ag{source} = "" }
			for my $ctx ( @$ar ) {
				my ($fi, $ln, $ctxmeta, $ctxdata) = @$ctx;
				my @ctxsize = split /\s/, $ctxmeta;
				# Support item types with only context info in this field
				my $ctxsize = scalar @ctxsize == 2 ? $ctxsize[1] : $ctxsize[0];
				( my $ctxpre = $ctxsize ) =~ s/:.+// or
					warn "CTXPRE didnt encounter x:y context ?\n";
				my $loc = "$fi:$ln";
				for my $arr ( @{ $covered{$key}{$fi} } ) {
					goto DONELOOP if $ln > $$arr[0] and $ln < $$arr[1];
				}
				my $ctxsdata = join "\n", @$ctxdata;
				if ( length $ctxsdata ) {
					my $ls = $ln - $ctxpre; # line start nr.
# XXX when xsltproc gets to support line numbering, add this below: XXX
#<screen linenumbering='numbered' startinglinenumber='$ls'><![CDATA[
					$$ag{source} .= <<ENDD;
<para>
</para>
<example>
<title>$loc ($ctxmeta)</title>

<screen><![CDATA[
$ctxsdata
]]></screen>
</example>

ENDD
					$$ag{"source ver"} = $hash{version};
				}
				my ($less,$more) = split /:/, $ctxsize;
				push @{ $covered{$key}{$fi} }, [ $ln-$less, $ln+$more ];
				DONELOOP:
			}
		}
	}
}

### THIS IS LAST RUN ###
# Final entry. That's where we add examples
# (which don't have version-specific data, they're always "latest")
while ( my($k,$v) = each %autogenerated ) {
	my %ag = %$v;

	# Do temporary-only modifications to %ag
	# At the end of the whole block, save completely generated XML to
	# %symbols hash.

	# Double check
	$ag{name} ||= $ag{id} || $k;
	$ag{name} = $hash{specific}{$ag{name}}{_name} if
		$hash{specific}{$ag{name}}{_name};
	
	# If we're dealing with a TAG, construct its "Default" section:
	if ( $ag{"_symbol type"} =~ /tag$/i and !$ag{default} ) {
		my @items;
		while ( my ($x,$y) = each %{ $hash{specific}{ $ag{name} } } ) {
			next unless $x =~ s/^_tagopt_//;
			push @items, "$x $y";
		}
		$ag{default} = join '</para><para>', @items;
	}

	# _See Also_ section: "bidirectional" linking
	if ( defined @{ $ag{'_see also'} } ) {
		my $list = $ag{'_see also'};
		@$list = grep {$autogenerated{$_} and $_ ne $ag{name}} @$list;
		#$ag{'see also'} = join ", ", @{ $ag{'_see also'} }; # Done below anyway
		
		for my $sym ( @$list ) {
			my $list2 = $autogenerated{$sym}{'_see also'};
			push @$list2, @$list, $k;
			{ my %h; @$list2 = grep {!$h{$_}++ and $sym ne $_} @$list2 }
			@{ $autogenerated{$sym}{'_see also'} } = @$list2;
			$autogenerated{$sym}{'see also'} = join ", ", @$list2;
		}
	}

	# Turn 'See Also' items to refentries
	my @see_items = @{ $ag{'_see also'} };
	# XXX only if it's the symbol from same category, otherwise use
	# olink to link between documents
	for my $itm ( @see_items ) {
		if ( $autogenerated{$itm} ) {
			my $linktype = "link"; # the default, linking inside the same document
			my $linkarg = "linkend";
			if ( $autogenerated{$itm}{'_symbol type'} eq $ag{'_symbol type'} ) {
				# Nothing, just use link linkend= if the targets are inside the same
				# document.
			} else {
				# If they're not, find appropriate external document to link to
				for my $sect ( keys %symbol_lists ) {
					if ( grep {/^$itm$/} @{ $symbol_lists{$sect} } ) {
						$linktype = "olink";
						$linkarg = "targetdoc='${sect}s' targetptr";
					}
				}
			}
			# Now that $linktype and $linkarg are set, make the link/citerefentry
			$itm =~ s/^(.+)$/<$linktype $linkarg='$1'><citerefentry><refentrytitle>$1<\/refentrytitle><manvolnum>7ic<\/manvolnum><\/citerefentry><\/$linktype>/;
		}
	}
	$ag{'see also'} = join ", ", @see_items;

	# Finally, set default values if they weren't overriden by real information
	for my $field (@page_order) {
		if ( ! $ag{$field} ) {
			if ( grep {/$field/} @mandatory) {
				push @{ $invalid{$k} },
					"Missing field '$field', using unsuitable default";
			}
			$ag{$field} = $defaults{$field};
		}
	}


	# SYNOPSIS LINE
	#if ( $ag{'_symbol type'} =~ /tag$/ ) {
	#	$ag{synopsis} = "[$ag{name} @{ $hash{specific}{$ag{name}}{order} }]";
	#}

	# DONE
	$ag{latest} = $hash{version};

	# Expand template
	my $template = join "", @template;
	{ no warnings;
	# I simply hate this, I can't find out which field
	# is undefined
	while ( $template =~ s/(\$ag{.*?})/$1/eem ) {};
	}

	# Save
	$symbols{$k} = $template unless ( $ag{ignore} and $ag{ignore} =~ /[y1d]/i );
}


# Produce reference sets (docbook element Reference contains RefEntries)
while (my ($k,$v) = each %symbol_lists ) {
	# Prepare reference page

	my $refpage = <<ENDD;
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook-Interchange XML V4.2//EN"
	"../docbook/docbookxi.dtd">

<reference id="${k}s">
	<title>Interchange Reference Pages: $longname{$k}s</title>
ENDD

	## Add items
	for my $item (sort @$v) {
		$refpage .= $symbols{$item} if $symbols{$item}
	}

	## Close up
	$refpage .= "\n" . '</reference>';

	# Dump page
	open OUT, "> refs/${k}s.xml" or
		die "Can't produce reference refs/$k.xml ($!)\n";
	print OUT $refpage;
	close OUT;
}

# Output the 'invalid' list
open INVOUT, "> tmp/missing" or
	die "Can't open tmp/missing ($!)\n";
print INVOUT Dumper \%invalid;
close INVOUT;

exit 0;

#################################################################
# Helpers below

sub process_symbol {
	my ($group, $name, $ref) = @_;

	return if ref $autogenerated{$name};

	# Make skel
	$autogenerated{$name} = {
		name => $name,
		id => $name,
		"_symbol type" => $group,
		"symbol type" => $general_desc{$group},
		"_first section" => ( $group =~ /tag$/ ? "TAG STRUCTURE" : "DEFAULT" ),
	};

	# Suplement with information from a control file
	populate($autogenerated{$name}, $name, 'control', 'override');
	populate($autogenerated{$name}, $name, '', 'append');
}

sub populate {
	my ($ref, $name, $file, $mode) = @_;

	# From one specific file (control file usually)
	if ( $file ) {
		open IN, "< refs/$name/$file" or do {
			push @{ $invalid{$name} }, "Requested file '$file' ($!)";
			return;
		};
		if ( $file eq 'control' ) {
			while (my $line = <IN>) {
				next if $line =~ /^\s*#/;
				chomp $line;
				$line =~ s/^\s+//;
				my ($sect,$text) = split /\s*:\s*/, $line, 2;
				goto SDONE if (!( defined $text and length $text ));
				if ( $sect ne 'missing' ) {
					if ( $mode eq 'override' ) {
						$$ref{lc $sect} = $text;
					} else {
						$$ref{lc $sect} .= '</para><para>' . $text;
					}
					if ( $sect =~ /^see also$/i ) {
						( my $list = $text ) =~ s/,/ /g;
						my @list = split /\s+/, $list;
						push @{ $$ref{'_see also'} }, @list;
						$$ref{'see also'} = join ", ", @{$$ref{'_see also'}};
					}
				} else {
					push @{ $invalid{$name} }, $text;
				}
				SDONE:
			}
		}
		close IN;

	# From other file sets
	} elsif (! length $file) { # all files
		opendir INDIR, "refs/$name/" or do {
			push @{ $invalid{$name} }, "Missing directory (all other errors follow from this)";
			return;
		};
		while (my $fn = readdir INDIR) {
			next if $fn =~ /^\.|^CVS$/;
			next if $fn eq 'control';
			open INF, "< refs/$name/$fn" or
				die "Can't open refs/$name/$fn ($!)\n";

			( my $sect = $fn ) =~ s/[\-\.\+_:\d].*//;
			$sect =~ s/([a-z])([A-Z])/$1 $2/g;
			$sect = lc $sect;

			if (!( grep {/^$sect/} @page_order )) {
				push @{ $invalid{$name} }, "Section '$sect' from file '$fn' won't be used (name not recognized)";
			}
			
			my $content = join "", <INF>;
			close INF;

			if ( $mode eq 'override' ) {
				$$ref{$sect} = $content;
			} elsif ( $mode eq 'append' ) {
				$$ref{$sect} .= $content;
			}
		}
		closedir INDIR;

	} else {
		die "Parsing of specific, non-control files not implemented\n";
	}
}

sub loaddb {
	my $dbpath = shift;

	unless ( exists $refcache{$dbpath} ) {
		open( IN, "< $dbpath") or
			die "Can't open database ($dbpath) ($!).\n";
		flock( IN, LOCK_SH ) or
			die "Can't shared-lock database ($dbpath) ($!).\n";
		$refcache{$dbpath} = fd_retrieve( \*IN );
		close IN or
			die "Can't properly close database ($dbpath) ($!).\n";
	}

	%hash = %{ $refcache{$dbpath} };

	if ( $dumpdb ) {
		print STDERR Dumper \%hash;
		exit 0;
	}
}

sub O { print "@_\n"; print STDOUT "@_\n" if $verbose }

__DATA__
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1>
<title>SYNOPSIS</title>
$ag{"synopsis"}
</refsect1>

<refsect1>
<title>$ag{"_first section"}</title>
<para>$ag{"default"}</para>
</refsect1>

<refsect1>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1>
<title>SYMBOL TYPE</title>
<para>$ag{"symbol type"}</para>
</refsect1>

<refsect1>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1>
<title>BUGS</title>
$ag{"bugs"}
</refsect1>

<refsect1>
<title>COPYRIGHT</title>
$ag{"copyright"}
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>

