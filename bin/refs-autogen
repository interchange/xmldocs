#! /usr/bin/perl

# docelic@icdevgroup.org

# The script parses cache files made by bin/stattree, and generates
# the refs/*.xml files.

use warnings;
use strict;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

{ no warnings;
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;
$ENV{XMLDOCS_CUR_DEVEL} ||= "";
}

my $dumpdb = 0;
my $verbose = 0;
my $OUTPUT = "OUTPUT";
my %refcache; # memory cache of Storable files. Not really needed but I 
              # copied old code which had it, so ...
my %hash; # complete tree data for each IC version we parse
my $cachedir = $ENV{CACHE} || "cache";
my %i; # internally derived data (only $i{ver} for now).
my %autogenerated; # Content of autogenerated symbols
my %invalid; # Information about missing documentation
my %covered; # Weed out duplicate context reports
my %symbol_lists; # symbols listed in categories
my %symbols; # FINAL symbol refentries (looks almost like %symbol_lists now ;-)
my %templates; # Templates for various symbol types
my $max_ctxs = 20; # Trim more than $max_ctxs source context reports
my @set_missing_all; # Helper to better manage %invalid
my @parsed_versions; # IC versions we parsed
my $specific_only; # Build only one specific .xml ?
my $output_spec; # 'list' produces tag list, 'xml' produces real xml source
my $output_both; # Unconditionally override $output_spec
my $no_autorefs; # Generate autorefs.ent collection of entities by default
my $autopath = "docbook/autorefs.ent";
my %dups; # List of symbols names that are not unique
my $last_path; # Last version we want docs generated for (say, 5.2.0).
my $compounds = 1; # Summarize similar symbol groups to single page?

my @page_order = (qw/purpose default structure synopsis description online example notes bugs/, "symbol type", "source", "author", "copyright", "see also", "directive type", "filter type");

unless ( GetOptions ( 
	"verbosedb|dumpdb|d!" => \$dumpdb,
	"verbose|v!" => \$verbose,
	"group|type|g|t=s" => \$specific_only,
	"output|o=s" => \$output_spec,
	"both|b!"    => \$output_both,
	"noentities|noents!" => \$no_autorefs,
	"last-path|last|lp=s" => \$last_path,
)) { die "Error parsing options\n" }

# Determine which stuff to output
my ( $output_list, $output_xml ) = (1,1);
if (!$output_both and $output_spec) {
	$output_spec =~ /\.?list$/ and ($output_list,$output_xml) = (1,0) or
	$output_spec =~ /\.?xml$/  and ($output_list,$output_xml) = (0,1) or
	die "Unknown output combination '$output_spec'\n";
}

$specific_only and $specific_only =~ s/s$//; # if user entered name in plural
@ARGV or die "Usage: $0 version[s]\n";

my %longname = (
	globvar => "Global Variable",
	catvar => "Catalog Variable",
	pragma => "Pragma",
	usertag => "User Tag",
	uitag => "User Interface Tag",
	systemtag => "System Tag",
	globconf => "Global Configuration Directive",
	catconf => "Catalog Configuration Directive",
	filter => "Filter",
	# Summarized / compounds:
	tag => "Tag",
	conf => "Configuration directive",
);

my %tagname = (
	globvar => "varname",
	catvar => "varname",
	pragma => "pragma",
	usertag => "tag",
	uitag => "tag",
	systemtag => "tag",
	globconf => "option",
	catconf => "option",
	filter => "filter",
	# Summarized:
	tag => "tag",
	conf => "option",
);

# Default fields
my %defaults = (
	synopsis => "&DEF_SYNOPSIS;",
	description => "&DEF_DESCRIPTION;",
	example => "&DEF_EXAMPLE;",
	notes => "&DEF_NOTES;",
	bugs => "&DEF_BUGS;",
	source => '&DEF_SOURCE;',
	author => "&DEF_AUTHOR;",
	copyright => "&DEF_COPYRIGHT;",
	'see also' => "&DEF_SEEALSO;",
	purpose => "&DEF_PURPOSE;",
	structure => "&DEF_STRUCTURE;",
	'directive type' => "&DEF_DIRECTIVE_TYPE;",
	'filter type' => "&DEF_FILTER_TYPE;",
);

my @mandatory = (qw/synopsis example description purpose/);

# General section intros and "outros"; they are set per-item and not
# only per-section as you could achieve with putting them in a template.
# The header is inserted
# *after* <title>, if title was specified in section definition.
my %item_header = (
	example => "<example>\n%s<para>",
);
my %item_footer = (
	example => "</para>\n</example>",
);

# Support preamble texts
my %preamble = (
	# Dude, this is 15 pages of text in place where there shouldn't be any really
	#tag => scalar readfile('glossary/ITL'),
	tag => "For a complete introduction to the &IC; Tag Language and " .
	"the supported syntax, please see the &glos-ITL; glossary entry.",
	conf => "",
	globvar => "",
	catvar => "",
	pragma => "",
	filter => "",
);

my @paths = @ARGV; # Versions requested
my $path; # Current path, used in loop for each version requested
my $dumppath; # Path to cache dump file
my $dumpdir;
my $lastpath; # Used if we want to stop before cvs-head

load_templates();

while ( $path = shift @paths) { # For each version specified
	$lastpath = $path;
	$dumppath = $path;
	$i{ver} = $dumppath;
	$dumpdir = "$dumppath/";
	$dumppath .= "/.cache.bin";

	# Load %hash with the cache for particular version (replaces previous one).
	# (which is OK since the data was extraced and we need previous cache
	# no more).
	loaddb( "$cachedir/$dumppath" );

	push @parsed_versions, $hash{version};

	# Outer loop: $gkey: symbol types (pragmas, globvars, ...)
	# Inner loop (~15 lines below): $key: actual symbols 
	while ( my ($gkey,$gval) = each %{ $hash{symbols} } ) {
		# Unfortunately - $specific_only is of limited use. If you use it,
		# the script won't catch symbol "migrations" - that is, for example,
		# a tag changing from ui_tag to usertag ...
		next if $specific_only and $gkey ne $specific_only;

		# Simply for display purpose
		if (! $symbol_lists{$gkey} ) {
			my ($name, @olist);

			$name = $gkey;
			my $pref = "";
			if ( $compounds ) {
				$gkey =~ /tag$/ and $name = 'tag';
				$gkey =~ /conf$/ and $name = 'conf';
				$pref = "${gkey}s -> ";
			}

			push @olist, "${pref}refs/${name}s.xml" if $output_xml;
			push @olist, "tmp/${gkey}s.list" if $output_list;
			local $" = ", ";
			print "GEN: @olist\n";
		}

		# Inner loop starts
		for my $key (keys(%$gval)) {
			my $val = $gval->{$key};

			my $found = 0; # Assume the symbol is new

			# Register the symbol name ($key) under group name ($gkey) in
			# %symbol_lists. We need to check if it already exists
			# under %symbol_lists. Searching in the same group is not enough
			# because group might have changed in next version (usertag -> uitag).
			# UPDATE: Item can only float between categories if it is a tag,
			# for all other symbols it means we have different symbols of
			# the same name (such as 'value' which is both a tag and filter).
			for my $gk ( keys %symbol_lists ) {
				if ( grep {/^$key$/} @{ $symbol_lists{$gk} } ) {
					if ( $gk ne $gkey ) { # SPLAT! Symbol changed category over time.
						
						# Found non-unique symbol name. (We are not interested in changes
						# from uitag->usertag (or similar), but only in real symbols that
						# are different but have same name). When that happens, 
						# refs/<file> needs to be deleted, and refs/<file>.$gk and 
						# refs/<file>.$gkey created to uniquely identify two separate items.
						if ( $gkey !~ /tag$/ ) {
							warn "$key IS BOTH $gk and $gkey!\n" if $verbose;
							push @{ $dups{$key} }, $gk, $gkey;
							goto SKIPDUPCHECK;
						}

						# (If we reached this point then the symbol is a tag and migrated
						# just to another tag subtype (ui, user or system)).
						# (That means we'll simply delete it from previous location, 
						# and it will be properly re-created at the new position as if it
						# was a regular new item).
						warn "$key CHANGED $gk // $gkey\n" if $verbose;
						my $prev = scalar @{ $symbol_lists{$gk} }; # Quick sanity check
						@{ $symbol_lists{$gk} } = grep {!/^$key$/} @{ $symbol_lists{$gk} };
						my $now = scalar @{ $symbol_lists{$gk} }; # Quick sanity check
						if ($prev - $now != 1) { warn "GREP took out more than 1 item!\n" }
					
					# Else the symbol is not new, didn't change category or antything
					# and it's a normal already-existing symbol.
					} else {
						$found++;
						#last; # let's not go into optimizations too early
					}
				}
			}
			SKIPDUPCHECK:
			!$found and push @{ $symbol_lists{$gkey} }, $key;

			# Define basic hash for the item ( $autogenerated{$gkey}{<name>} ), and
			# load values from files. The function returns if
			# $autogenerated{group}{<name>} is present already (that is, the basic
			# skeleton was already made).
			# It is okay to add info from refs/<name>/* to the item at this step
			# because that information is not version-specific; it's constant.
			# ** This fills %autogenerated **
			process_symbol($gkey, $key, $val);

			# Register the presence of this item in this version.
			push @{ $autogenerated{$gkey}{$key}{"_available in"} }, $hash{version};

			# Prepare source contexts, avoiding those cases
			# where a symbol appears multiple times inside the same
			# context lines span, but by stattree it gets counted
			# as a new context. (which is correct technically, but not
			# suitable for display).
			# 
			# Having this code here will make all symbols
			# end up having the last version they appear in displayed in
			# source section.
			my $ag = $autogenerated{$gkey}{$key};
			my $ar = $hash{symbols}{ $$ag{"_symbol type"} }{$key};

			# Do one silly thing (again, compound docs are tearing me apart).
			if ( $gkey eq 'globconf' ) {

				@{ $$ag{'_directive type'} } = ("Global directive");
				# For config directives, we can't simply do as above because catconf
				# would then overrides globconf, and that's not okay! (We need to
				# preserve the source contexts from globconfs, so we must handle
				# this with some brains in the process).
				# Here's what we do:
				# For each globconf, we add catconf source contexts to it (if
				# catconf variant exists), and we delete it from catconfs hash. Then
				# what is left in catconfs are only catconf directives, and are simply
				# added to final $symbols{conf} because they wont overwrite anything.
				if ( $hash{symbols}{catconf}{$key} ) {
					push @{ $ar }, @{ $hash{symbols}{catconf}{$key} };
					delete $hash{symbols}{catconf}{$key};
					push @{ $$ag{'_directive type'} }, "Catalog directive";
				}
			}

			if ( $ar ) {
				$$ag{source} = "";
				$covered{$gkey}{$key} = {}; # This one was though to find ;-)
			}

			my $ctxtotal = scalar @$ar;
			my $ctxshown = 0;
			for my $ctx ( @$ar ) {

				my $fi = $$ctx{file};
				my $ln = $$ctx{lnum} || 0; #HA! How come $$ctx{lnum} is undefined??
			
				# See if the source context was already listed. (I don't think this
				# can happen - that the same one appears twice). This code actually
				# weeds out *different* but overlapping contexts.
				for my $arr ( @{ $covered{$gkey}{$key}{$fi} } ) {
					next if !$ln or !$$arr[0] or !$$arr[1];
					if ($ln > $$arr[0] and $ln < $$arr[1]) {
						$ctxtotal--;
						goto DONELOOP;
					}
				}

				# Make sure we don't overdo it with source contexts.
				# MV_PAGE appears on like 31 place. We definitely don't need to
				# see more than 10; let's say 20.
				if ( $ctxshown++ > $max_ctxs ) {
					print STDERR "$$ag{name} has ", scalar @$ar,
						" contexts, limiting to $max_ctxs\n" if $verbose;
					goto DONELOOP;
				}

				# We 'shift' here because we unshifted 1 row to match line
				# numbers with array indexes
				my $ctxsdata = join "\n", @{ $$ctx{ctx} };
				if ( length $ctxsdata ) {
					my $ls = $$ctx{ctxs}; # line start nr.
					( my $plf = $$ctx{file} ) =~ s#.+?/##;

					# Well now dude, *some* files from lib/Vend/* somehow lose the
					# prefix "lib/". I have no idea how - but we'll fix it when 
					# it happens.
					$plf =~ /^Vend/ and $plf = "lib/" . $plf;

					#my $loc = "$$ctx{file}:$$ctx{lnum}";
					my $loc = $$ctx{file};
					
					my ( $cstart, $cend, $ctxmeta ) = ("", "", "");
					my $all = 0; # Showing all for an item?

					if ( $gkey !~ /(tag|filter)$/ ) {
						# WE SHOW ONLY PART OF CONTEXT FOR THOSE
						$$ctx{ctxpre} ||= 0; $$ctx{ctxpost} ||= 0; # *confs don't have it
						$cstart = $$ctx{lnum}-$$ctx{ctxpre};
						$cend = $cstart+$$ctx{lnum}+$$ctx{ctxpost};

					} else {
						# WE SHOW ALL FOR THOSE
						$all++;
						$cstart = $$ctx{ctxs} || 1;
						# T h o s e  p e s k y  o f f s e t s
						$cend = $cstart + scalar @{$$ctx{ctx}}-1;
						$cstart == 1 and $cend -= 1;
					}

					# General fix, shouldn't break anything (Heh, you bet..)
					# We just put $cstart and $cend within some limits (to avoid
					# cases reporting like context showing lines from -3 to 12, or
					# 15 to 29 when there are only 25 lines total).
					$cstart <= 0 and $cstart = 1;
					$cend >= $cstart+@{ $$ctx{ctx} } and
						$cend = $cstart+@{ $$ctx{ctx} }-1;

					my $eb = 1; # Include ending bracket?
					if ( ! $all ) {
						$ctxmeta = "<sbr/>Line $ln";
						if ( $cstart == $cend ) {
							$eb = 0;
						} else {
							$ctxmeta .= " (context shows lines " .
								( $cstart . "-" .  $cend );
						}
					} else {
						$ctxmeta = "<sbr/>Lines: $cend";
					}

					if ( $$ctx{funclnum} ) {
						$ctxmeta .= " in $$ctx{func}():$$ctx{funclnum}" ;
					}
					$ctxmeta .= ")" if (!$all and $eb);
					my $r = $hash{revision}{$plf}->[0];
					my $d = $hash{revision}{$plf}->[1];
					my $revinfo = "";
					if ( $gkey !~ /conf$/ ) {
						if ( $r and $d ) {
							$revinfo = "(rev. $r from $d)";
							}
					}


					{ no warnings; # XXX If someone can figure out which of the used vars here is undefined...
#<screen linenumbering='numbered' startinglinenumber='$ls'>
					$$ag{source} .= <<ENDD;
<para>
</para>
<figure>
<title>$loc $revinfo$ctxmeta</title>

<screen>
<![CDATA[$ctxsdata]]>
</screen>
</figure>

ENDD
					}
					$$ag{"source ver"} = $hash{version};
				}
				push @{ $covered{$gkey}{$key}{$fi} }, [ $$ctx{ctxs}, $$ctx{ctxe} ];
				DONELOOP:
			}

			$$ag{"ctxs total"} = $ctxtotal;
			$$ag{"ctxs shown"} = $ctxshown < $max_ctxs ? $ctxshown : $max_ctxs;
		}
	}

	# If this is the last version we want (so, manual break), then stop here.
	# This is for cases where you want to generate docs for say, 5.2.0 and not
	# always cvs-head
	last if $last_path and $last_path eq $path;
}

### THIS IS LAST RUN (Split in multiple loops to avoid chicken-and-egg problem)###
# Final entry. That's where we add examples
# (which don't have version-specific data, they're always "latest")
# FINAL / PASS 1
for my $group ( keys %autogenerated ) {
while ( my($k,$v) = each %{ $autogenerated{$group} } ) {
	my %ag = %$v;

	# Do temporary-only modifications to %ag
	# At the end of the whole block, save completely generated XML to
	# %symbols hash.

	# Double check
	$ag{name} ||= $ag{id} || $k;
	$ag{name} = $hash{specific}{$ag{name}}{_name} if
		$hash{specific}{$ag{name}}{_name};

	################################################################
	# DO STUFF HERE IF IT'S COMMON FOR ALL SYMBOLS. IF it's not,
	# jump out to symbol-specific-subroutine that will handle that.
	################################################################

	# _See Also_ section: "bidirectional" linking
	# Interesting how I actually had this very good idea in the beginning,
	# then I commented it thinking it's crap, and now I'm back to just
	# modifying it a little so it works as expected again.
	# As they say. it works like a charm ;-)
	if ( defined @{ $ag{'_see also'} } ) {
		my $list = $ag{'_see also'};
		my %tmp;

		# This loop is now needed since we added the concept of groups
		# in %autogenerated.
		for my $gr ( keys %autogenerated ) {
			$tmp{$_} = $gr
				for (grep {$autogenerated{$gr}{$_} and $_ ne $ag{name}} @$list);
		}
		@$list =keys %tmp;
		
		for my $sym ( @$list ) {
			my $list2 = $autogenerated{$tmp{$sym}}{$sym}{'_see also'};
			push @$list2, @$list, $k;
			{ my %h; @$list2 = grep {!$h{$_}++ and $sym ne $_} @$list2 }
			@{ $autogenerated{$tmp{$sym}}{$sym}{'_see also'} } = @$list2;
		}
	}

}
}
# FINAL / PASS 2
for my $group ( keys %autogenerated ) {
while ( my($k,$v) = each %{ $autogenerated{$group} } ) {
	my %ag = %$v;

	# Turn 'See Also' items to refentries
	goto END_SEEALSO unless $ag{'_see also'};
	my @see_items = @{ $ag{'_see also'} };

	for my $itm ( @see_items ) {
		next if $itm =~ /^</; # Don't touch if it's a manually written XML link
		my $linktype = "link"; # Assume link to symbol of same type
		my $linkarg = "linkend";
		if ( $autogenerated{$group}{$itm} ) {
			# This means our item and the target it links to are of same type. So, 
			# nothing, just use default link/linkend=
		} else {
			# If they're not, find appropriate external document to link to
			for my $sect ( keys %symbol_lists ) {
				if ( grep {/^$itm$/} @{ $symbol_lists{$sect} } ) {

					# Add all cases where it's still possible that items are of different
					# groups but will find their way to the same document in the end:
					if ( $compounds and substr($group,-1,3) eq substr($sect,-1,3) ) {
						# Do nothing, it's okay.
					} elsif ( $compounds and substr($group,-1,4) eq substr($sect,-1,4) ) {
						# Do nothing, it's okay.
					} else {
						# Documents won't end up in the same file even with $compounds
						# enabled.
						$linktype = "olink";
						$linkarg = "targetdoc='${sect}s' targetptr";
					}

				}
			}
		}
		## Now that $linktype and $linkarg are set, make the link/citerefentry
		$itm or warn "NO ITM???\n";
		$itm =~ s/^(.+)$/<$linktype $linkarg='$1'><citerefentry><refentrytitle>$1<\/refentrytitle><manvolnum>7ic<\/manvolnum><\/citerefentry><\/$linktype>/;
	}
	$ag{'_see also'} = @see_items;
	$ag{'see also'} = join ", ", @see_items;
	END_SEEALSO:

	# Finally, set default values for fields that have no real information
	for my $field (@page_order) {
		if ( ! $ag{$field} ) {
			if ( grep {/$field/} @mandatory) {
				push @{ $invalid{$k} },
					"Missing field '$field', using unsuitable default";
			}
			$ag{$field} = $defaults{$field};
		}
	}


	##########################################################################
	# "Stringify" array values
	$ag{"available in"} = join ", ", @{ $ag{"_available in"} };
	# Compress 4.6.0, 4.8.0, 5.0.0 to 4.6.0-5.0.0
	$ag{'available in'} = compress_availability($ag{'_available in'});

	$ag{"_directive type"} and 
	$ag{"directive type"} = join "<sbr/>\n", @{ $ag{"_directive type"} };


	# DONE
	$ag{latest} = $hash{version};

#	# Visually mark NEW (cvs-head) items . HEH, too bad this doesn't work.
#	DocBook strips non-text stuff when creating TOC entries. So under symbol
#	names you see a nice NEW icon, but in TOC that plain text looks very poor.
	if ( @{ $ag{'_available in'} } == 1 and
			${$ag{'_available in'}}[0] eq $ENV{XMLDOCS_CUR_DEVEL}) {
		$ag{purpose} = <<ENDD;
<inlinemediaobject>
<imageobject>
<imagedata fileref="./images/new.png" format="PNG"/>
</imageobject>
<textdata>
<phrase>NEW</phrase>
</textdata>
</inlinemediaobject>
$ag{purpose}
ENDD
	}


	if ( my $fname = $hash{specific}{$ag{name}}{"_tagopt_maproutine"} ) {
		# This means tag is MapRoutined, so it doesn't use any other 
		# symbols directly, but possibly the maproutined function do.
		# So as far as symbol usage goes, the tag in question actually
		# impersonates the maproutined function it uses.

		# XXX Should work, but just somehow it doesnt, so comment for now.
		#$hash{uses}{$group}{$ag{name}} = $hash{uses}{function}{ $fname };
	}
	

	# The 'structure' field will show which other symbols the current
	# symbol uses. Fill it:
	if ( $hash{uses}{$group}{$ag{name}} ) {
		$ag{structure} = "This tag appears to be affected by, or affects, the following:\n";
		while (my($k,$v)=each %{ $hash{uses}{$group}{$ag{name}} }) {
			s/^(.+)$/<$tagname{lc $k}>$1<\/$tagname{lc $k}>/ for @$v;
			local $" = ", ";
			$k = $longname{$k};
			$ag{structure} .= "${k}s: @$v<sbr/>\n";
		}
	} else {
		$ag{structure} = "This tag does not appear to be affected by, or affect, the rest of Interchange.\n";
	}

	# Expand template
	my $template = $templates{ $ag{"_symbol type"} };
	$template or warn "No template $ag{'_symbol type'} ?\n";

	{ no warnings;
	# I simply hate this, I can't find out which field is undefined
	#while ( $template =~ s/(\$ag{.*?})/$1/eem ) {}; # Am I stupid?
	$template =~ s/(\$ag{.*?})/$1/geem;
	}

	# Save
	$symbols{$group}{$k} =
		$template unless ( $ag{ignore} and $ag{ignore} =~ /[y1d]/i );
}
}

if ( $compounds ) {
	# Let's see if this is the place to override output document name. For example,
	# we want all types of tags to end up in ictags.xml. We'll add other
	# symbol-specific overrides later (globconfs/catconfs come to mind).
	# I don't like the idea but, 'manchmal muss man tun, was man tun muss' ;)
	# We could generate both separate-file and onefile formats, but then we'd have
	# to adjust all links differently and all that crap so it's not worth the fuss..
	$symbols{tag} = {
		%{ $symbols{systemtag} },
		%{ $symbols{usertag} },
		%{ $symbols{uitag} },
	};

	$symbols{conf} = {
		%{ $symbols{globconf} },
		%{ $symbols{catconf} },
	};

	delete @symbols{qw/systemtag usertag uitag/};
	delete @symbols{qw/globconf catconf/};
}


# Produce reference sets (docbook element Reference contains RefEntries)
for my $group ( keys %symbols ) {
	# Prepare reference page

	my $refpage = <<ENDD;
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook-Interchange XML V4.2//EN"
	"../docbook/docbookxi.dtd">

<reference id="${group}s">
	<title>Interchange Reference Pages: $longname{$group}s</title>

  <partintro>
  <para>
  $preamble{$group}
  </para>
  </partintro>

ENDD

	## Add items
	for my $key (sort keys %{ $symbols{$group} }) {
		$refpage .= $symbols{$group}{$key}
	}

	## Close up
	$refpage .= "\n" . '</reference>';

	# Dump page
	my $prefix = ""; #$compounds ? "ic" : "";
	open OUT, "> refs/$prefix${group}s.xml" or
		die "Can't produce reference refs/$prefix${group}s.xml ($!)\n";
	print OUT $refpage;
	close OUT;
#}
}


# Output lists
if ( $output_list ) {
	my @syms = $specific_only ? ($specific_only) : keys %symbol_lists;
	local $" = "\n";
	for my $sym (@syms) {
		my @list = sort @{ $symbol_lists{$sym} };
		open OUT, "> tmp/${sym}s.list" or die "Can't open tmp/${sym}s.list ($!)\n";
		print OUT "@list";
		close OUT;
	}
}

# Output the 'invalid' list
$invalid{$_} = ("Missing all (undocumented)") for @set_missing_all;
open INVOUT, "> tmp/missing" or
	die "Can't open tmp/missing ($!)\n";
print INVOUT Dumper \%invalid;
close INVOUT;

# Output autorefs.ent
unless ( $no_autorefs ) {
	open ATD, "> $autopath" or die "Can't wropen $autopath ($!)\n";
	print "GEN: $autopath\n";

	while (my($g,$kr) = each %symbol_lists) {
		for $_ (@$kr) {
			my $tag;

			if ( $g =~ /tag$/ ) {
				$tag = 'tag';
			} elsif ( $g =~ /pragma$/ ) {
				$tag = 'pragma';
			} elsif ( $g =~ /var$/ ) {
				$tag = 'varname';
			} elsif ( $g =~ /conf$/ ) {
				$tag = 'option';
			} elsif ( $g =~ /filter$/ ) {
				$tag = 'filter';
			} else {
				die "UNKNOWN $g\n";
			}

			( my $prefix = $g ) =~ s/.+(tag|conf|var)$/$1/;

#<!ENTITY $_ "<olink targetdoc='${g}s' targetptr='$_'>$_</olink>">
			print ATD <<ENDD;
<!ENTITY ${prefix}-$_ "<$tag>$_</$tag>">
ENDD
		}
	}

	close ATD;
}

# Boy, did I previously misplace this critical code...
if ( $dumpdb ) { print STDERR Dumper \%autogenerated; exit 0; }

exit 0;

#################################################################
# Helpers below

sub process_symbol {
	my ($group, $name, $ref) = @_;

	# XXX: Ok, now, I figured this thing out. Some files changed location
	# between versions and their type changed, so this fell apart.
	# ( for example, usertag moved to uitag ).
	# To fix this, we simply leave item skeleton to be autoregenerated in
	# those cases (we could leave through in any case, but that would waste
	# time).

	# Move some of this to the above code that calls process_symbol() ? No.
	# what the f* was I thinking when I disabled this region?
	# Suddenly how at some days I see everything, and then on some I am like
	# an idiot.. This whole block below is not used any more.
	#
	#if ( ref $autogenerated{$group}{$name} ) { # Symbol known
	#	if ( $autogenerated{$group}{$name}{"_symbol type"} ne $group ) { # But changed group
	#		# The good entry is already in symbol_lists (done in wanted()), we
	#		# only need to remove the obsolete one:
	#		print "YES FOR $name ($group/$autogenerated{$group}{$name}{'_symbol type'}\n";
	#		@{$symbol_lists{$group} } = grep{!/^$name$/} @{ $symbol_lists{$group}};
	#		# XXX In a new system, add file pathname change to NOTES section.
	#		# And correct the field (we can't simply let through to regenerate
	#		# the skeleton because that would delete previous "available in"
	#		# information):
	#		$autogenerated{$group}{$name}{"_symbol type"} = $group;
	#		#$autogenerated{$group}{$name}{"symbol type"}="&SYMBOL_".uc($group).";";
	#	}
	#	return
	#}

	# How easily one can comment too much of code ;-)
	return if ( ref $autogenerated{$group}{$name} );

	# Make skel
	$autogenerated{$group}{$name} = {
		name => $name,
		id => $name,
		"_symbol type" => $group,
		#"symbol type" => "&SYMBOL_" . uc($group) . ";",
	};

	# Skel is done, now:

	# Suplement with information from a control file. Control file overrides
	# settings, but this is only available if multi-file method is used to
	# document an item (so, refs/itemname/*). If multi-file method is not used,
	# nothing gets done here.
	populate($autogenerated{$group}{$name}, $group, $name, 'control', 'override');

	# Supplement information with other files, that is, either
	# all but 'control' file from refs/itemname/*, or just refs/itemname
	# if single-file method is used (which is standard).
	populate($autogenerated{$group}{$name}, $group, $name, '', 'append');
}

sub populate {
	my ($ref, $group, $name, $file, $mode) = @_;

	my $fgroup = $group; $fgroup =~ /tag$/ and $fgroup = 'tag';
	my $specpath = "refs/$name.$fgroup";  # Specific path
	my $genpath = "refs/$name";          # Generic path (no type visible in it)
	my $refpath = -e $specpath ? $specpath : $genpath; # USE THIS FOR PATHNAME

	# If symbol name is not unique, then explicit type must be specified.
	# (That is, the 'value' symbols needs to have refs/value.tag and
	# refs/value.filter);
	# Config directives (globconfs/catconfs) can have one file (refs/<name>)
	# to document both symbols at once.
	if (
		$dups{$name} and     # Symbol name is non-unique
		-e $genpath and      # Generic file exists (refs/<name>)
		!-e $specpath and    # But special files don't (refs/<name>.<group>)
		$group !~ /conf|var$/ ) {# And it's not a cfg directive or globvar/catvar
		                         #for which we tolerate
		local $" = " AND ";
		die "Symbol '$name' is: @{ $dups{$name} }. Must have refs/<name>.<type>\n";
	}

	# From one specific file (control file usually)
	if ( $file ) {
		if ( -d $refpath ) {
			open IN, "< $refpath/$file" or do {
				push @{ $invalid{$name} }, "Requested file '$file' ($!)";
				return;
			};
			if ( $file eq 'control' ) {
				while (my $line = <IN>) {
					next if $line =~ /^\s*#/;
					chomp $line;
					$line =~ s/^\s+//;
					my ($sect,$text) = split /\s*:\s*/, $line, 2;
					update_field($mode, $group, $name, $ref, $file, $sect, $text)
						if ( defined $text and length $text );
				}
			} else {
				die "TODO: Reading from non-control files not supported.\n";
			}
			close IN;
		}

	# From other file sets
	} elsif (! length $file) { # all files

		if ( -d "$refpath" ) {
			opendir INDIR, "$refpath/" or do {
				warn "Can't open $refpath/ ($!)\n";
				return
			};
			while (my $fn = readdir INDIR) {
				next if $fn =~ /^\.|^CVS$/;
				next if $fn eq 'control';
				open INF, "< $refpath/$fn" or
					die "Can't open $refpath/$fn ($!)\n";

				my $sect = $fn;

				my $content = join "", <INF>;
				close INF;

				update_field ("append", $group, $name, $ref, $fn, $sect, $content);
			}
			closedir INDIR;

		} elsif ( -f "$refpath" ) {
			open IN, "< $refpath" or do {
				warn "Can't open $refpath ($!)\n";
				return
			};
			my @c = <IN>;
			close IN;

			my ( $section, $title, $pre_content, $content, $post_content );
			# XXX check if it's empty, then don't update
			for my $line (@c) {
				# Here we support format of this kind:
				# __NAME__ section name: section title
				# The 'title' part will be automatically wrapped in a 
				# <title> element.
				if ( $line =~ /^__NAME__\s+(.+)\s*$/ ) {
					# Support for this exists only in this format, it's not
					# supported in control files or name/*. And fortunately, since
					# we didn't modify the templates to do this trick, those old files
					# can remain as-they-are and work properly !! Excellent.
					my ( $sec, $title) = split /\s*:\s*/, $1, 2;
					$section = $sec;
					$title = $title ? "<title>$title</title>" : "";
					$pre_content =  sprintf($item_header{$section}||"", $title);
					$post_content = sprintf($item_footer{$section}||"", $title);
					next

				} elsif ( $line =~ /^__END__/ ) {
					update_field("append", $group, $name, $ref, "$refpath", $section, $content, $pre_content, $post_content);
					$section = "";
					$title = "";
					$pre_content = "";
					$content = "";
					$post_content = "";
				}
				# If not a beginning or end of section, simply add line to content
				$content .= $line if $section;
			}

		} else {
			push @set_missing_all, $name;
		}

	} else {
		die "Parsing of specific, non-control files not implemented\n";
	}
}

sub update_field {
	my ($mode, $group, $name, $sref, $fn, $sect, $content, $pre, $post) = @_;

	$sect =~ s/[\-\.\+_:\d].*//;
	$sect =~ s/([a-z])([A-Z])/$1 $2/g;
	$sect = lc $sect;

	$pre ||= "";
	$post ||= "";

	if ( $sect ne 'missing' ) {

		if (!( grep {/^$sect/} @page_order ) and $sect ne 'ignore') {
			push @{ $invalid{$name} }, "Section '$sect' from file '$fn' won't be used (name not recognized)";
		}

		## Section-specific mangling here
		## TODO seems promising, but needs to be wrapped in an element that would
		# fit in .xml
		if ( $sect eq 'online' ) {
		#	# Extract programlistings.. dude! Ok, not as bad-looking as I thought:)
		#	my $tmp = $content; my $code = "";
		#	while($tmp =~ s#<programlisting>(.*?)</programlisting>##s){$code .= $1}

		#	$code or
		#		die "Empty online example for $name (no <programlisting> found)\n";

		#	# Let's see if we'll get away this easy
		#	$content .= qq{
		#	<programlisting>
		#		<textobject>
		#		<textdata>
		#		[/restrict]
		#		$code
		#		[restrict]
		#		</textdata>
		#		</textobject>
		#	</programlisting>
		#	};

		# And rewrite section to example:
			$sect = 'example';

		} elsif ( $sect =~ /^see also$/i ) {
			( my $list = $content ) =~ s/,/ /g;
			my @list = split /\s+/, $list;
			@{ $$sref{'_see also'} } = @list;
		}
		
		if ( $mode eq 'override' ) {
			$$sref{lc $sect} = $pre . $content . $post if $content;
		} else {
			# Causes problems
			#$$sref{lc $sect} .= $$sref{lc $sect} ?
			#	'</para><para>' . $content : $content;
			$$sref{lc $sect} .= $pre . $content . $post if $content;
		}

	} else { # "Missing" section
		my @missing_list = split /\n/, $content;
		push @{ $invalid{$name} }, $_ for @missing_list
	}
}

sub loaddb {
	my $dbpath = shift;

	unless ( exists $refcache{$dbpath} ) {
		open( IN, "< $dbpath") or
			die "Can't open database ($dbpath) ($!).\n";
		flock( IN, LOCK_SH ) or
			die "Can't shared-lock database ($dbpath) ($!).\n";
		$refcache{$dbpath} = fd_retrieve( \*IN );
		close IN or
			die "Can't properly close database ($dbpath) ($!).\n";
	}

	%hash = %{ $refcache{$dbpath} };
}

sub compress_availability {
	my @avails = my @orig = @{ (shift) };
	@avails or die "compress_availability(): Shouldn't happen";

	# XXX this needs work, but at the moment it serves us well
	# (it can't handle like x-y, z, a-b. It only handles start-end)

	my $start = shift @avails;
	my $si; # starting index
	my $cl = 0; # compress level
	for (my $i=0; $i<@parsed_versions;$i++) {
		if ( $parsed_versions[$i] eq $start ) {
			$si = $i;
		}
	}
	my $end;
	while ( $_ = shift @avails ) {
		if ( $parsed_versions[++$si] eq $_ ) {
			$end = $_;
			$cl++;
		} else {
			unshift @avails, $_;
			last
		}
	}
	local $" = ", ";
	if ( $cl > 1 ) {
		unshift @avails, "$start-$end";
		return "@avails"
	} else {
		return "@orig"
	}
}

sub O { print "@_\n"; print STDOUT "@_\n" if $verbose }


#
# TEMPLATES, SYMBOL-SPECIFIC
#
#
#<refsect1 id='$ag{"name"}_online' condition='online'>
#<title>ONLINE EXAMPLES</title>
#$ag{"online"}
#</refsect1>

sub readfile {
	my $file = shift;
	open IN, $file or die "Can't open $file ($!)\n";
	my @slurp = <IN>;
	close IN;

	local $" = "";
	wantarray? @slurp : "@slurp"
}

sub load_templates {


$templates{pragma} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>VALUE</title>
<cmdsynopsis>
$ag{"synopsis"}
</cmdsynopsis>
</refsect1>

<refsect1 id='$ag{"name"}_default'>
<title>DEFAULT</title>
<para>$ag{"default"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"} ($ag{"ctxs shown"}/$ag{"ctxs total"} contexts shown):</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{filter} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_type'>
<title>FILTER TYPE</title>
<para>$ag{"filter type"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{usertag} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>PARAMETERS</title>

<informaltable pgwide='1' frame='none'>
<tgroup cols='5' align='left'>
<colspec colname='arg'/>
<colspec colname='pos'/>
<colspec colname='req'/>
<colspec colname='def'/>
<colspec colname='dsc'/>

<thead>
<row>
<entry>Argument</entry>
<entry>Pos.</entry>
<entry>Req.</entry>
<entry>Default</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
$ag{"synopsis"}
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_structure'>
<title>BEHAVIOR</title>
<para>$ag{"structure"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__


$templates{globconf} = <<'__ENDP__';
<refentry id="$ag{id}">

<refmeta>
<refentrytitle>$ag{"name"}</refentrytitle>
<manvolnum>7ic</manvolnum>
<refmiscinfo class="title">$ag{"name"}</refmiscinfo>
</refmeta>

<refnamediv>
<refname>$ag{"name"}</refname>
<refpurpose>$ag{"purpose"}</refpurpose>
</refnamediv>

<refsect1 id='$ag{"name"}_synopsis'>
<title>SYNOPSIS</title>
<cmdsynopsis>
$ag{"synopsis"}
</cmdsynopsis>
</refsect1>

<refsect1 id='$ag{"name"}_description'>
<title>DESCRIPTION</title>
<para>$ag{"description"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_type'>
<title>DIRECTIVE TYPE</title>
<para>$ag{"directive type"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_examples'>
<title>EXAMPLES</title>
$ag{"example"}
</refsect1>

<refsect1 id='$ag{"name"}_notes'>
<title>NOTES</title>
<para>$ag{"notes"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_availability'>
<title>AVAILABILITY</title>
<para>$ag{"name"} is available in Interchange versions:
</para><para>
$ag{"available in"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_source'>
<title>SOURCE</title>
<para>Interchange $ag{"source ver"}:
</para>
$ag{source}
</refsect1>

<refsect1 id='$ag{"name"}_authors'>
<title>AUTHORS</title>
<para>$ag{"author"}</para>
</refsect1>

<refsect1 id='$ag{"name"}_seeAlso'>
<title>SEE ALSO</title>
<para>$ag{"see also"}</para>
</refsect1>

</refentry>
__ENDP__

$templates{globvar} = $templates{pragma};
$templates{catvar} = $templates{pragma};
$templates{uitag} = $templates{usertag};
$templates{systemtag} = $templates{usertag};
$templates{catconf} = $templates{globconf};

}

