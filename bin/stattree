#!/usr/bin/perl
#
# Perl script to build Interchange source tree statistics.
# Data is collected and dumped using Storable, that's where 
# this script's job ends.
#
# Other tools can then only read the dump to get information,
# they shouldn't parse the sources again.
#

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

# Dumper behavior
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;

# Vars
my $verbose = 0;
my $cachedir = $ENV{CACHE} || "cache";
my %hash; # Will contain data to be dumped
my $cpath = $ENV{PWD};
# Source contexts
my $ctx_p = 10; # How much context lines to show before
my $ctx_n = 4; #                                after

# All file types should be listed here or the stats wont. It should be
# reported if an unknown file is found in the archive
# Order is important. First match wins.
my %binary_types = (
	images => [qw/\.gif \.jpeg \.jpg \.png \.bmp/],
	);
my %ascii_types = (
	database => [qw|\.(..)?sql \.ora \..?dbm \.notes \.csv
		/products/\S+\.txt \.asc|],
	release_helpfile => [qw/^WHATSNEW-\d+\.\d+ README(\..+)? TODO
		^LICENSE ^MANIFEST(\.skip)? ^UPGRADE \.cvsignore \.append/],
	build_helpfile => [qw/configure ^debian.* ^SPECS.*/],
	catalog_helpfile => [qw/\.access \.log \.error \.(auto)?number \.empty/],
	config => [qw/\.cfg \.dist/],
	c => [qw/\.c \.in/],
	perl => [qw/\.pl \.pm/],
	usertag => [qw|UserTag/\S+\.tag \.tag|],
	systemtag => [qw|SystemTag/\S+\.coretag|],
	uitag => [qw|UI_Tag/\S+\.coretag|],
	filter => [qw/\.filter/],
	actionmap => [qw/\.am/],
	html => [qw/\.css \.html?/],
	widget => [qw/\.widget/],
	profile => [qw|/profiles/.+ \.profiles \.login \.order|],
	globalsub => [qw|/globalsub/.+|],
	variable => [qw|/vars/.+ /variables/.+|],
);


# A general overview: how many different contents do we have
my $binary_types;
my $ascii_types;
for ( keys %binary_types ) { $binary_types += scalar @{ $binary_types{$_} } }
for ( keys %ascii_types ) { $ascii_types += scalar @{ $ascii_types{$_} } }
$hash{total}{known_types} = $binary_types + $ascii_types;
$hash{total}{known_binary_types} = $binary_types;
$hash{total}{known_ascii_types} = $ascii_types;


# Parse args (not much available anyway :)
unless ( GetOptions ( 
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV == 1 or die "Usage: $0 path[/] \n";

# $path is the directory to process, $dumppath is relocated name, say
# sources/cvs-head becomes output/cvs-head/cache
my $path = shift;
( my $dumppath = $path ) =~ s#.+?/##;
my $dumpdir = $dumppath;
my %i = ( ver => $dumpdir );
$i{ver} =~ s/\/$//;
`mkdir -p $cachedir/$dumpdir` unless -e "$cachedir/$dumpdir";
$dumppath .= "/.cache.bin";

# Convenient routine to just discover all files in a module
chdir $path; # Go into the directory
find({
	wanted => \&wanted,
	bydepth => 0,
	no_chdir=> 1,
}, ".");
chdir $cpath; # Return to starting location


# Dump
dumpdb( "$cachedir/$dumppath" );

# Save human-readable %hash ?
if ( $verbose ) {
	#print STDERR Dumper \%hash;
	open OUT, "> tmp/$i{ver}.hash" or die "Can't open tmp/$i{ver}.hash ($!)\n";
	print OUT Dumper \%hash;
	close OUT;
}

exit 0;

#################################################################
# Helpers below
sub wanted {
	( my $file = $_ ) =~ s/^\.\///;

	# Things we ignore
	return if /(^|\/)(CVS|\.cvs|\.svn|\.autoload)(\/.+[^\/])?$/;
	
	stat($file) or warn "Can't stat '$file' ? ($!)\n";

	# totals
	if ( -d $file ) {
		$hash{total}{directories}++;
		$hash{tree}{$file}{type} = "directory";
		return; # This is enough for directories
	} else {
		$hash{total}{files}++;
		$hash{total}{size} += (stat _)[7];
	}

	# file data itself (collected for all types)
	$hash{tree}{$file} = {
		size => (stat _)[7],
		atime => (stat _)[8],
		mtime => (stat _)[9],
		ctime => (stat _)[10],
	};

	#
	# Make sure the file extension is known (we're entering
	# content-based processing now, not filename-based as above).

	my $ftype;
	my $fsubtype;
	my $fext;
	# Binary
	for my $k ( keys %binary_types ) {
		for my $t ( @{ $binary_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "binary"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	#Text
	for my $k ( keys %ascii_types ) {
		for my $t ( @{ $ascii_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "ascii"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	# Unknown // TODO pay more attention to this, this should rarely happen,
	# even if we're not interested in some files, they *should* be matched
	# in %ascii_types/%binary_types above to provide accurate statistics.
	print STDERR "$file UNKNOWN\n" if $verbose;
	return; # We're not interested in handling that

	EXTDONE:

	# file, ftype, fsubtype and fext are known here.
	# file is filename, ftype is binary/ascii, fsubtype is key in 
	# %ascii_types/%binary_types hash, fext is extension
	$hash{total}{$ftype."_files"}++;
	$hash{total}{filetypes}{$fsubtype}++;
	$hash{total}{matches}{$fext}++;
	$hash{tree}{$file}{type} = "$ftype";
	$hash{tree}{$file}{subtype} = "$fsubtype";
	$hash{tree}{$file}{ext} = "$fext";

	# No more job with binary files
	return if $ftype eq 'binary';

	# Also ignore some directories (don't parse contents in them)
	# (following a -core discussion from Aug 2004).
	return if $file =~ m#^(eg|extra|SPECS|debian|scripts|extensions)/#;

	# Open text file, parse contents
	open IN, "< $file" or die "Can't open $file ($!)\n";
	my @file = <IN>;
	unshift @file, ""; # Match index numbers with line numbers
	close IN;

	# Global variables to use from the loop below
	my @gfunc = (qw/unknown -1/); # 2 elements: func name, line num

	for (my $lnum = 1; $lnum < scalar @file; $lnum++) {
		my $line = $file[$lnum];

		$hash{tree}{$file}{lines}++ ;
		$hash{total}{lines}++ ;

		# It's the main configure file, pick up the ICVERSION variable
		if ( $file eq 'configure' ) {
			for $_ (@file) {
				if ( /^ICVERSION=(['"])(\d+\.\d+\.\d+)\1/ ) {
					if ( !$hash{version} or "$hash{version}" eq "$2" ) {
						$hash{version} = $2
					}
					last;
				}
			}
			# ICVERSION must be known here, or someone's playing, or
			# it's a pre-5.0 version which doesnt have that.
			unless ( $hash{version} ) {
				warn "Wasn't able to determine " .
					'^ICVERSION=([\'"])(\d+\.\d+\.\d+)\1 from the main ' .
					"./configure script. Will use one from directory name. " .
					"(This is OK for pre-5.0 versions).\n";
				$hash{version} = $i{ver};
			}

		# Perl program file
		} elsif ( $fsubtype eq 'perl' ) {
			my $pod = 0;
			if ( $line =~ /^\s*#/ ) {
				$hash{tree}{$file}{comments}++ ;
				$hash{total}{perl_comments}++;
				# TODO check if the comment contains ::log[A-Z]\w+
				# to discover calls to logGlobal/logDebug
			} elsif ( $line =~ /\s+#/ ) {
				$hash{tree}{$file}{gray}++ ;
				$hash{total}{perl_gray}++;
			} elsif ( $line =~ /^=(head|over|item)/) {
				$hash{tree}{$file}{pod}++;
				$hash{total}{perl_pod}++;
				$pod++;
			} elsif ( $line =~ /^=cut/) {
				$hash{tree}{$file}{pod}++;
				$hash{total}{perl_pod}++;
				$pod = 0;
			} elsif ( $line =~ /^\s*$/ ) {
				$hash{tree}{$file}{empty}++;
				$hash{total}{perl_empty}++;
			} elsif ( ! $pod ) {
				# The default is code
				$hash{tree}{$file}{code}++;
				$hash{total}{perl_code}++;

				######################################################
				# Discover pragmas
				# Ph33r, PH33R my MaD R3G3X skiLLz! ;-)
				# This matches $::Pragma->{} or $$::Pragma{}
				#if ( $line =~ /(()|\$())\$::Pragma(->\2|\3){(\w+?)}/ ) {
				if ( $line =~ /\$::Pragma->{(\w+?)}/ or 
					$line =~ /\$Vend::Cfg->{Pragma}{(\w+?)}/ ) {
					#push @{ $hash{symbols}{pragma}{$5} }, <- for use with above
					push @{ $hash{symbols}{pragma}{$1} },
						# TODO Here, and 2 places below: make sure if ctx is say, 5:5,
						# it always shows that much (that is, workaround file beginning/
						# file end problems - pad with empty lines or something).
						[ "$i{ver}/$file", $lnum, "$gfunc[0]:$gfunc[1] $ctx_p\:$ctx_n", [format_ctx(@file[$lnum-$ctx_p..$lnum+$ctx_n])] ];
				}
				
				######################################################
				# Diskover global variables
				if ( $line =~ /(()|\$())\$Global::Variable(->\2|\3){(\w+?)}/ ) {
					push @{ $hash{symbols}{globvar}{$5} },
						[ "$i{ver}/$file", $lnum, "$gfunc[0]:$gfunc[1] $ctx_p\:$ctx_n", [format_ctx(@file[$lnum-$ctx_p..$lnum+$ctx_n])] ];
				}
				# A little catch
				if ( $line =~ /\$Tag->var\s*\(\s*(["'])(\S+?)\1(\s*,\s*(\d))?/ ) {
					push @{ $hash{symbols}{globvar}{$5} },
						[ "$i{ver}/$file", $lnum, "$gfunc[0]:$gfunc[1] $ctx_p\:$ctx_n", [format_ctx(@file[$lnum-$ctx_p..$lnum+$ctx_n])] ];
					warn "\$Tag->var syntax never used in .pl/.pm files by now.
						I'll register that, but is it a mistake? ($2, $4)\n";
				}
				
				######################################################
				# See if it's a beginning of a subroutine name, and remember the
				# name/linenum.
				if ( $line =~ m#^\s*sub\s+(\w+)\s*\{\s*$# ) {
					$hash{total}{perl_functions}++;
					@gfunc = ( $1, $lnum );
				}

			} else {
				warn "IMPOSSIBLE\n";
			}

		# TODO:
		# - parse contents, identify blocks and add to appropriate
		#   counters.
		# - code with inline comments or html with tags count as "gray area"
		#   (adds 1 to both)

		##########################################################
		# Found a tag
		} elsif ( $fsubtype =~ /^(user|ui|system)tag$/ )  {
			#$hash{total}{$fsubtype . "s"}++;
			$file =~ m#(\w+?)\.(core)?tag$# or
				warn "I know $file is a tag but regex doesn't match it\n";

			my %specific; # Item-specific data
			my @tags; # Support multiple tags defined in the same file

			# This is where we parse the tag file. We should discover settings like
			# HasEndTag, Order, and so on.
			for my $_l (@file) {
				next unless $_l =~ /^usertag\s/i;
				my @lis = split /\s+/, $_l;
				shift @lis; # Remove "Usertag" which is first in the list

				# Tag name as really defined, not just the file name
				# (Most often, the difference is in _ and -).
				my $tn = shift @lis;

				my $tagopt = shift @lis;
				next if $tagopt =~ /^(routine|documentation)$/i;
				if ( "@lis" =~ /<</ ) {
					warn "TODO: Unsupported << in $tn\n";
					next;
				}

				# New tag name we didn't see yet (either first run or another tag defined)
				{ no warnings;
				if (!grep{/^$tn$/}@tags and $lis[0] !~ /^alias$/i) { push @tags, $tn }
				}

				$specific{$tn}{"_tagopt_$tagopt"} = "@lis";
			}
			
			# For each tag found in the file, create appropriate data in hash.
			for my $tagname ( @tags ) {
				push @{ $hash{symbols}{$fsubtype}{$tagname} }, 
					[ "$i{ver}/$file", scalar @file, "1:" . scalar @file, [ format_ctx(@file) ] ];
				$hash{specific}{$tagname} = $specific{$tagname};
			}
			
			last;
		}
	}
}

# Format the context lines before saving to the db
sub format_ctx {
	map { s/\t/  /g; chomp } @_;
	return @_;
}

# Storable dumper
sub dumpdb {

	my $dbpath = shift;

	sysopen( OUT, $dbpath, O_WRONLY|O_CREAT, 0664 ) or
		die "Can't dump ($dbpath) ($!).\n";
	flock( OUT, LOCK_EX ) or
		die "Can't exclusive-lock ($dbpath) ($!).\n";;
	nstore_fd(\%hash, \*OUT ) or
		die "Can't dump to ($dbpath) ($!).\n";
	truncate( OUT, tell(OUT));
	close OUT or
		die "Can't properly close database ($dbpath) ($!).\n";

}

