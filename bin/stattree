#!/usr/bin/perl
#
# docelic@icdevgroup.org
#
# Perl script to build Interchange source tree statistics,
# contexts and symbols information.
# Data is collected and dumped using Storable, that's where 
# this script's job ends.
#
# Other tools can then only read the dump to get information,
# they shouldn't parse the sources again.
#
# Now that I learned most of the requirements, looks like this
# script is up to the task and is pretty decent altogether
# 

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;
use File::Basename;

# Dumper behavior
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;

# Vars
my $verbose = 0;
my $cachedir = $ENV{CACHE} || "cache";
my %hash; # Will contain data to be dumped
my $cpath = $ENV{PWD};
# Source contexts
my $ctx_p = 10; # How much context lines to show before
my $ctx_n = 4; #                                after
my %cvsmap; # Each key (full filename) contains array: [ver, date]

# All file types should be listed here or the stats wont. It should be
# reported if an unknown file is found in the archive
# Order is important. First match wins.
my %binary_types = (
	images => [qw/\.gif \.jpeg \.jpg \.png \.bmp/],
	);
my %ascii_types = (
	database => [qw|\.(..)?sql \.ora \..?dbm \.notes \.csv
		/products/\S+\.txt \.asc|],
	release_helpfile => [qw/^WHATSNEW-\d+\.\d+ README(\..+)? TODO
		^LICENSE ^MANIFEST(\.skip)? ^UPGRADE \.cvsignore \.append/],
	build_helpfile => [qw/configure ^debian.* ^SPECS.*/],
	catalog_helpfile => [qw/\.access \.log \.error \.(auto)?number \.empty/],
	config => [qw/\.cfg \.dist/],
	c => [qw/\.c \.in/],
	perl => [qw/\.pl \.pm/],
	uitag => [qw|UI_Tag/\S+\.(core)?tag|],
	systemtag => [qw|SystemTag/\S+\.(core)?tag|],
	usertag => [qw|UserTag/\S+\.tag \.tag|],
	filter => [qw/\.filter/],
	actionmap => [qw/\.am/],
	html => [qw/\.css \.html?/],
	widget => [qw/\.widget/],
	profile => [qw|/profiles/.+ \.profiles \.login \.order|],
	globalsub => [qw|/globalsub/.+|],
	variable => [qw|/vars/.+ /variables/.+|],
);


# A general overview: how many different contents do we have
my $binary_types;
my $ascii_types;
for ( keys %binary_types ) { $binary_types += scalar @{ $binary_types{$_} } }
for ( keys %ascii_types ) { $ascii_types += scalar @{ $ascii_types{$_} } }
$hash{total}{known_types} = $binary_types + $ascii_types;
$hash{total}{known_binary_types} = $binary_types;
$hash{total}{known_ascii_types} = $ascii_types;


# Parse args (not much available anyway :)
unless ( GetOptions ( 
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV == 1 or die "Usage: $0 path[/] \n";

# $path is the directory to process, $dumppath is relocated name, say
# sources/cvs-head becomes output/cvs-head/cache
my $path = shift;
( my $dumppath = $path ) =~ s#.+?/##;
my $dumpdir = $dumppath;
my %i = ( ver => $dumpdir );
$i{ver} =~ s/\/$//;
`mkdir -p $cachedir/$dumpdir` unless -e "$cachedir/$dumpdir";
$dumppath .= "/.cache.bin";

# Ok, onto some work now
chdir $path; # Go into the directory

# Let's just pick CVS lines first:
my @files = `find . -name Entries | cut -b 3-`;
for my $entry ( @files ) {
	chomp $entry;
	my $dir;
	( $dir = $entry ) =~ s#/?CVS/Entries$## or
		warn "Can't remove Entries\$ ('$dir')?\n";
	open CVSIN, "< $entry" or warn "Can't open '$entry' ($!)\n";
	while ( my $cvsline = <CVSIN> ) {
		next unless $cvsline =~ s#^/##;
		my ($fn, $ver, $time) = split /\//, $cvsline;

		$path = $dir ? "$dir/$fn" : $fn;
		$hash{revision}{"$path"} = [ $ver, $time ];
	}
	close CVSIN;
}

# Convenient routine to just discover all files
find({
	wanted => \&wanted,
	bydepth => 0,
	no_chdir=> 1,
}, ".");
chdir $cpath; # Return to starting location


# Dump
dumpdb( "$cachedir/$dumppath" );

# Save human-readable %hash ?
if ( $verbose ) {
	#print STDERR Dumper \%hash;
	open OUT, "> tmp/$i{ver}.hash" or die "Can't open tmp/$i{ver}.hash ($!)\n";
	print OUT Dumper \%hash;
	close OUT;
}

exit 0;

#################################################################
# Helpers below
sub wanted {
	( my $file = $_ ) =~ s/^\.\///;

	# Things we ignore
	return if /(^|\/)(CVS|\.cvs|\.svn|\.autoload)(\/.+[^\/])?$/;
	
	stat($file) or warn "Can't stat '$file' ? ($!)\n";

	# totals
	if ( -d $file ) {
		$hash{total}{directories}++;
		$hash{tree}{$file}{type} = "directory";
		return; # This is enough for directories
	} else {
		$hash{total}{files}++;
		$hash{total}{size} += (stat _)[7];
	}

	# file data itself (collected for all types)
	$hash{tree}{$file} = {
		size => (stat _)[7],
		atime => (stat _)[8],
		mtime => (stat _)[9],
		ctime => (stat _)[10],
	};

	#
	# Make sure the file extension is known (we're entering
	# content-based processing now, not filename-based as above).

	my $ftype;
	my $fsubtype;
	my $fext;
	# Binary
	for my $k ( keys %binary_types ) {
		for my $t ( @{ $binary_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "binary"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	#Text
	for my $k ( keys %ascii_types ) {
		for my $t ( @{ $ascii_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "ascii"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	# Unknown // TODO pay more attention to this, this should rarely happen,
	# even if we're not interested in some files, they *should* be matched
	# in %ascii_types/%binary_types above to provide accurate statistics.
	print STDERR "$file UNKNOWN\n" if $verbose;
	return; # We're not interested in handling that

	EXTDONE:

	# file, ftype, fsubtype and fext are known here.
	# file is filename, ftype is binary/ascii, fsubtype is key in 
	# %ascii_types/%binary_types hash, fext is extension
	$hash{total}{$ftype."_files"}++;
	$hash{total}{filetypes}{$fsubtype}++;
	$hash{total}{matches}{$fext}++;
	$hash{tree}{$file}{type} = "$ftype";
	$hash{tree}{$file}{subtype} = "$fsubtype";
	$hash{tree}{$file}{ext} = "$fext";

	# No more job with binary files
	return if $ftype eq 'binary';

	# Also ignore some directories (don't parse contents in them)
	# (following a -core discussion from Aug 2004).
	return if $file =~ m#^(eg|extra|SPECS|debian|scripts|extensions)/#;

	# Open text file, parse contents
	open IN, "< $file" or die "Can't open $file ($!)\n";
	my @filedata = <IN>;
	unshift @filedata, ""; # Match index numbers with line numbers
	close IN;

	# Global variables to use in the loop below
	my @gfunc = (qw/unknown 0/); # 2 elements: func name, line num

	# Prepare context hash so that all data is available to the
	# line handler functions later
	my %c = ( 
		file => $file,
		ftype => $ftype,
		fsubtype => $fsubtype,
		fext => $fext,
		gfunc => \@gfunc,
		filedata => \@filedata,
		ctx_p => $ctx_p,
		ctx_n => $ctx_n,
	);


	for (my $lnum = 1; $lnum < scalar @filedata; $lnum++) {
		$c{line} = $filedata[$lnum];
		$c{lnum} = $lnum;

		$hash{tree}{$file}{lines}++ ;
		$hash{total}{lines}++ ;

		# It's the main configure file, pick up the ICVERSION variable
		if ( $c{file} eq 'configure' ) {
			for $_ (@filedata) {
				if ( /^ICVERSION=(['"])(\d+\.\d+\.\d+)\1/ ) {
					if ( !$hash{version} or "$hash{version}" eq "$2" ) {
						$hash{version} = $2
					}
					last;
				}
			}
			# ICVERSION must be known here, or someone's playing, or
			# it's a pre-5.0 version which doesnt have that.
			unless ( $hash{version} ) {
				warn "Wasn't able to determine " .
					'^ICVERSION=([\'"])(\d+\.\d+\.\d+)\1 from the main ' .
					"./configure script. Will use one from directory name ($i{ver}).\n"
					unless $i{ver} =~ /^4/; # ignore warning for 4.x versions
				$hash{version} = $i{ver};
			}

		# Perl program file
		} elsif ( $c{fsubtype} eq 'perl' ) {
			my $pod = 0;
			if ( $c{line} =~ /^\s*#/ ) {
				$hash{tree}{$c{file}}{comments}++ ;
				$hash{total}{perl_comments}++;
				# TODO check if the comment contains ::log[A-Z]\w+
				# to discover calls to logGlobal/logDebug/logError
			} elsif ( $c{line} =~ /\s+#/ ) {
				$hash{tree}{$c{file}}{gray}++ ;
				$hash{total}{perl_gray}++;
			} elsif ( $c{line} =~ /^=(head|over|item)/) {
				$hash{tree}{$c{file}}{pod}++;
				$hash{total}{perl_pod}++;
				$pod++;
			} elsif ( $c{line} =~ /^=cut/) {
				$hash{tree}{$c{file}}{pod}++;
				$hash{total}{perl_pod}++;
				$pod = 0;
			} elsif ( $c{line} =~ /^\s*$/ ) {
				$hash{tree}{$c{file}}{empty}++;
				$hash{total}{perl_empty}++;
			} elsif ( ! $pod ) {
				# The default is code
				$hash{tree}{$c{file}}{code}++;
				$hash{total}{perl_code}++;

				line_findPragmas(\%c);
				line_findGlobVars(\%c);
				line_findFunctionName(\%c);

			} else {
				warn "IMPOSSIBLE case in $file\n";
			}

		##########################################################
		# Found a tag
		} elsif ( $c{fsubtype} =~ /^(user|ui|system)tag$/ )  {
			#$hash{total}{$fsubtype . "s"}++;
			$c{file} =~ m#(\w+?)\.(core)?tag$# or
				warn "I know $c{file} is a tag but regex doesn't match it\n";

			my %specific; # Item-specific data
			my @tags; # Support multiple tags defined in the same file

			# This is where we parse the tag file. We should discover settings like
			# HasEndTag, Order, and so on.
			for (my $lnum = 1; $lnum < scalar @filedata; $lnum++) {
				my $_l = $filedata[$lnum];
				next unless $_l =~ /^usertag\s/i;
				my @lis = split /\s+/, $_l;
				shift @lis; # Remove "Usertag" which is first in the list

				# Tag name as really defined, not just the file name
				# (Most often, the difference is in _ and -).
				my $tn = shift @lis;

				my $tagopt = shift @lis;
				next if $tagopt =~ /^documentation$/i;

				# See if it's a routine and parse routine lines as usual perl lines
				if ( $tagopt =~ /^routine$/i and "@lis" =~ /\s*<<(\S+)\s*$/i ) {
					my $ender = $1;
					for (my $lnum2 = $lnum; $lnum2 < scalar @filedata; $lnum2++) {
						my $_t = $filedata[$lnum2];
						last if $_t =~ /^$ender$/;

						$c{line} = $_t;
						$c{lnum} = $lnum2;

						# For example, this should find PGP_HOME
						line_findPragmas(\%c);
						line_findGlobVars(\%c);
						line_findFunctionName(\%c);
					}
					next;
				}
				
				if ( "@lis" =~ /<</ and $tagopt !~ /^routine/i ) {
					warn "TODO: Unsupported << in $tn (in $i{ver})\n" if $verbose;
					next;
				}

				# New tag name we didn't see yet
				# (either first run or another tag definition in the same file)
				{ no warnings;
				if (!grep{/^$tn$/}@tags and $lis[0] !~ /^alias$/i) { push @tags, $tn }
				}

				$specific{$tn}{"_tagopt_$tagopt"} = "@lis";
			}
			
			# For each tag found in the file, create appropriate data in hash.
			for my $tagname ( @tags ) {
				push @{ $hash{symbols}{$c{fsubtype}}{$tagname} }, {
					%c,
					file => "$i{ver}/$c{file}",
					lnum => scalar @filedata,
					ctxpre => $ctx_p,
					ctxpost => $ctx_n,
					ctxs => 1,
					ctxe => scalar @filedata,
					ctx => [ format_ctx(@filedata) ] };

				$hash{specific}{$tagname} = { # Append/update, don't overwrite
					%{ $hash{specific}{$tagname} || {}},
					%{ $specific{$tagname} || {}},
				};
			}
			
			last;
		}
	}
}

# Format the context lines before saving to the db
sub format_ctx {
	for $_ ( @_ ) { s/\t/  /g; chomp };
	# Find the number of starting whitespace common to all lines
	# and trim it.
	my $common;
	for $_ ( @_ ) {
		if (/\S/ and /^( +)/) {
			$common = length($1) if !defined $common || length($1) < $common
		}
		# Catch runaway lines (produces crapload of things, so refine
		# search before starting to use it)
		#if ( $_ =~ /\S\s{10,}/ ) {
		#	warn "Runaway '$_' ?\n";
		#}
	}
	if ( $common ) { s/^ {$common}// for @_ }
	return @_;
}

# Storable dumper
sub dumpdb {

	my $dbpath = shift;

	sysopen( OUT, $dbpath, O_WRONLY|O_CREAT, 0664 ) or
		die "Can't dump ($dbpath) ($!).\n";
	flock( OUT, LOCK_EX ) or
		die "Can't exclusive-lock ($dbpath) ($!).\n";;
	nstore_fd(\%hash, \*OUT ) or
		die "Can't dump to ($dbpath) ($!).\n";
	truncate( OUT, tell(OUT));
	close OUT or
		die "Can't properly close database ($dbpath) ($!).\n";

}

# HELPERS

sub line_findPragmas {
	my %ptr = %{ (shift) };
	# This matches $::Pragma->{} or $$::Pragma{}
	#if ( $line =~ /(()|\$())\$::Pragma(->\2|\3){(\w+?)}/ ) {
	if ( $ptr{line} =~ /\$::Pragma->{(\w+?)}/ or         
			$ptr{line} =~ /\$Vend::Cfg->{Pragma}{(\w+?)}/ ) {
	#push @{ $hash{symbols}{pragma}{$5} }, <- for use with above
		push @{ $hash{symbols}{pragma}{$1} }, {
	# TODO Here, and 2 places below: make sure if ctx is say, 5:5,
	# it always shows that much (that is, workaround file beginning/
	# file end problems - pad with empty lines or something).
		%ptr,
		file => "$i{ver}/$ptr{file}",
		lnum => $ptr{lnum},
		func => ${$ptr{gfunc}}[0],
		funclnum => ${$ptr{gfunc}}[1],
		ctxpre => $ptr{ctx_p},
		ctxpost => $ptr{ctx_n},
		ctxs => $ptr{lnum} - $ptr{ctx_p},
		ctxe => $ptr{lnum} + $ptr{ctx_n},
		ctx => [format_ctx(@{$ptr{filedata}}[$ptr{lnum}-$ptr{ctx_p}..$ptr{lnum}+$ptr{ctx_n}])]
	};
	}
}

sub line_findGlobVars {
	######################################################
	# Diskover global variables
	my %c = %{ (shift) };
	if ( ( $c{line} =~ /(()|\$())\$Global::Variable(->\2|\3){(\w+?)}/ or
		$c{line} =~ /\$Tag->var\s*\(\s*(["'])(\S+?)\1(\s*,\s*(\d))?/ ) and $5 ) {
		push @{ $hash{symbols}{globvar}{$5} }, {
			%c,
			file => "$i{ver}/$c{file}",
			lnum => $c{lnum},
			func => ${$c{gfunc}}[0],
			funclnum => ${$c{gfunc}}[1],
			ctxpre => $c{ctx_p},
			ctxpost => $c{ctx_n},
			ctxs => $c{lnum} - $c{ctx_p},
			ctxe => $c{lnum} + $c{ctx_n},
			ctx => [format_ctx(@{$c{filedata}}[$c{lnum}-$c{ctx_p}..$c{lnum}+$c{ctx_n}])]
		};
	}
}

sub line_findFunctionName {
	######################################################
	# See if it's a beginning of a subroutine name, and remember the
	# name/linenum.
	my %c = %{ (shift) };
	if ( $c{line} =~ m#^\s*sub\s+(\w+)\s*\{\s*$# ) {
		$hash{total}{perl_functions}++;
		@{ $c{gfunc} } = ( $1, $c{lnum} );
	}
}

