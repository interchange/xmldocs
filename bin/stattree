#!/usr/bin/perl
#
# Perl script to build Interchange source tree statistics.
# Data is collected and dumped using Storable, that's where 
# this script's job ends.
#
# Other tools can then only read the dump to get information,
# they shouldn't parse the sources again.
#

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;

# Dumper behavior
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;

# Vars
my $verbose = 0;
my $cachedir = $ENV{CACHE} || "cache";
my %hash;
my $cpath = $ENV{PWD};
my $ctx_p = 10; # How much context lines to show before
my $ctx_n = 4; #                                after

# All types should be listed here or the stats wont. It should be
# reported if an unknown file is found in the archive
# Order is important. First match wins.
my %binary_types = (
	images => [qw/\.gif \.jpeg \.jpg \.png \.bmp/],
	);
my %ascii_types = (
	database => [qw|\.(..)?sql \.ora \..?dbm \.notes \.csv
		/products/\S+\.txt \.asc|],
	release_helpfile => [qw/^WHATSNEW-\d+\.\d+ README(\..+)? TODO
		^LICENSE ^MANIFEST(\.skip)? ^UPGRADE \.cvsignore \.append/],
	build_helpfile => [qw/configure ^debian.* ^SPECS.*/],
	catalog_helpfile => [qw/\.access \.log \.error \.(auto)?number \.empty/],
	config => [qw/\.cfg \.dist/],
	c => [qw/\.c \.in/],
	perl => [qw/\.pl \.pm/],
	usertag => [qw|UserTag/\S+\.tag \.tag|],
	systemtag => [qw|SystemTag/\S+\.coretag|],
	uitag => [qw|UI_Tag/\S+\.coretag|],
	filter => [qw/\.filter/],
	actionmap => [qw/\.am/],
	html => [qw/\.css \.html?/],
	widget => [qw/\.widget/],
	profile => [qw|/profiles/.+ \.profiles \.login \.order|],
	globalsub => [qw|/globalsub/.+|],
	variable => [qw|/vars/.+ /variables/.+|],
);

my $binary_types;
my $ascii_types;
for ( keys %binary_types ) { $binary_types += scalar @{ $binary_types{$_} } }
for ( keys %ascii_types ) { $ascii_types += scalar @{ $ascii_types{$_} } }

# A general overview: how many different contents do we have
$hash{total}{known_types} = $binary_types + $ascii_types;
$hash{total}{known_binary_types} = $binary_types;
$hash{total}{known_ascii_types} = $ascii_types;


# Parse args (not much available anyway :)
unless ( GetOptions ( 
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV == 1 or die "Usage: $0 path[/] \n";

# $path is the dir to process, $dumppath is relocated name, say
# sources/cvs-head becomes output/cvs-head/cache
my $path = shift;
( my $dumppath = $path ) =~ s#.+?/##;
my $dumpdir = $dumppath;
my %i = (
	ver => $dumpdir,
);
$i{ver} =~ s/\/$//;
`mkdir -p $cachedir/$dumpdir` unless -e "$cachedir/$dumpdir";
$dumppath .= "/.cache.bin";

# Convenient routine to just discover all files in a module
chdir $path; # Go into the directory
find({
	wanted => \&wanted,
	bydepth => 0,
	no_chdir=> 1,
}, ".");
chdir $cpath; # Return to starting location


# Dump
print STDERR Dumper \%hash if $verbose;
dumpdb( "$cachedir/$dumppath" );

exit 0;

#################################################################
# Helpers below
sub wanted {
	( my $file = $_ ) =~ s/^\.\///;

	# Things we ignore
	return if /(^|\/)(CVS|\.cvs|\.svn|\.autoload)(\/.+[^\/])?$/;
	
	stat($file);

	# totals
	if ( -d $file ) {
		$hash{total}{directories}++;
		$hash{tree}{$file}{type} = "directory";
		return;
	} else {
		$hash{total}{files}++;
		$hash{total}{size} += (stat _)[7];
	}

	# file data itself (collected for all types)
	$hash{tree}{$file} = {
		size => (stat _)[7],
		atime => (stat _)[8],
		mtime => (stat _)[9],
		ctime => (stat _)[10],
	};

	#
	# Make sure the file extension is known (we're entering
	# content-based processing now, not filename-based as above).

	my $ftype;
	my $fsubtype;
	my $fext;
	# Binary
	for my $k ( keys %binary_types ) {
		for my $t ( @{ $binary_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "binary"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	#Text
	for my $k ( keys %ascii_types ) {
		for my $t ( @{ $ascii_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "ascii"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	# Unknown // TODO pay more attention to this
	print STDERR "$file UNKNOWN\n" if $verbose;
	return; # We're not interested in handling that

	EXTDONE:

	# ftype, fsubtype and fext are known here
	$hash{total}{$ftype."_files"}++;
	$hash{total}{filetypes}{$fsubtype}++;
	$hash{total}{matches}{$fext}++;
	$hash{tree}{$file}{type} = "$ftype";
	$hash{tree}{$file}{subtype} = "$fsubtype";
	$hash{tree}{$file}{ext} = "$fext";

	# No more job with binary files
	return if $ftype eq 'binary';

	# Open text file, parse contents
	open IN, "< $file" or die "Can't open $file ($!)\n";
	my @file = <IN>;
	unshift @file, ""; # Match indices with line numbers
	close IN;

	for (my $lnum = 1; $lnum < scalar @file; $lnum++) {
		my $line = $file[$lnum];

		$hash{tree}{$file}{lines}++ ;
		$hash{total}{lines}++ ;

		# It's the main configure file, pick up the ICVERSION variable
		if ( $file eq 'configure' ) {
			for $_ (@file) {
				if ( /^ICVERSION=(['"])(\d+\.\d+\.\d+)\1/ ) {
					if ( !$hash{version} or "$hash{version}" eq "$2" ) {
						$hash{version} = $2
					} else {
						die "I got inconsistent ^ICVERSION= information: " .
							"existing is $hash{version}, new is $2. " . 
							"Not continuing, fix manually\n";
					}
					# break; # We *could* stop processing here,
					         # but we won't.
				}
			}
			# ICVERSION must be known here, or someone's playing
			unless ( $hash{version} ) {
				warn "Wasn't able to determine " .
					'^ICVERSION=([\'"])(\d+\.\d+\.\d+)\1 from the main ' .
					"./configure script. Will use one from directory name.\n";
				$hash{version} = $i{ver};
			}

		# Perl program file
		} elsif ( $fsubtype eq 'perl' ) {
			my $pod = 0;
			if ( $line =~ /^\s*#/ ) {
				$hash{tree}{$file}{comments}++ ;
				$hash{total}{perl_comments}++;
				# TODO check if the comment contains ::log[A-Z]\w+
			} elsif ( $line =~ /\s+#/ ) {
				$hash{tree}{$file}{gray}++ ;
				$hash{total}{perl_gray}++;
			} elsif ( $line =~ /^=(head|over|item)/) {
				$hash{tree}{$file}{pod}++;
				$hash{total}{perl_pod}++;
				$pod++;
			} elsif ( $line =~ /^=cut/) {
				$hash{tree}{$file}{pod}++;
				$hash{total}{perl_pod}++;
				$pod = 0;
			} elsif ( $line =~ /^\s*$/ ) {
				$hash{tree}{$file}{empty}++;
				$hash{total}{perl_empty}++;
			} elsif ( ! $pod ) {
				# The default is code
				$hash{tree}{$file}{code}++;
				$hash{total}{perl_code}++;

				# Discover pragmas
				# Ph33r, PH33R my MaD R3G3X skiLLz! ;-)
				# This matches $::Pragma->{} or $$::Pragma{}
				#if ( $line =~ /(()|\$())\$::Pragma(->\2|\3){(\w+?)}/ ) {
				if ( $line =~ /\$::Pragma->{(\w+?)}/ or 
					$line =~ /\$Vend::Cfg->{Pragma}{(\w+?)}/ ) {
					#push @{ $hash{symbols}{pragma}{$5} }, <- for use with above
					push @{ $hash{symbols}{pragma}{$1} },
						# TODO Here, and 2 places below: make sure if ctx is say, 5:5,
						# it always shows that much (that is, workaround file beginning/
						# file end problems).
						[ $file, $lnum, "$ctx_p\:$ctx_n", [@file[$lnum-$ctx_p..$lnum+$ctx_n]] ];
				}

				# Diskover global variables
				if ( $line =~ /(()|\$())\$Global::Variable(->\2|\3){(\w+?)}/ ) {
					push @{ $hash{symbols}{globvar}{$5} },
						[ $file, $lnum, "$ctx_p\:$ctx_n", [@file[$lnum-$ctx_p..$lnum+$ctx_n]] ];
				}
				if ( $line =~ /\$Tag->var\s*\(\s*(["'])(\S+?)\1(\s*,\s*(\d))?/ ) {
					push @{ $hash{symbols}{globvar}{$5} },
						[ $file, $lnum, "$ctx_p\:$ctx_n", [@file[$lnum-$ctx_p..$lnum+$ctx_n]] ];
					warn "\$Tag->var syntax never used in .pl/.pm files by now.
						I'll register that, but is it a mistake? ($2, $4)\n";
				}
			} else {
				warn "IMPOSSIBLE\n";
			}
		}

		# TODO:
		# - parse contents, identify blocks and add to appropriate
		#   counters.
		# - code with inline comments or html with tags count as "gray area"
		#   (adds 1 to both)

	}
}

# Storable dumper
sub dumpdb {

	my $dbpath = shift;

	sysopen( OUT, $dbpath, O_WRONLY|O_CREAT, 0664 ) or
		die "Can't dump ($dbpath) ($!).\n";
	flock( OUT, LOCK_EX ) or
		die "Can't exclusive-lock ($dbpath) ($!).\n";;
	nstore_fd(\%hash, \*OUT ) or
		die "Can't dump to ($dbpath) ($!).\n";
	truncate( OUT, tell(OUT));
	close OUT or
		die "Can't properly close database ($dbpath) ($!).\n";

}

#
#	This is how the final dumped hash looks like:
# The %hash is per-module (main directory) of course!
#
# %hash = (
# 	# General overview, summarized statistics
# 	total => {
#
# 		known_types        # all extensions: binary + text
#
# 		known_binary_types # how many file types are considered binary
# 		
# 		known_ascii_types  # how many file types are considered text
# 		
#			files            # total number of files (non-dirs)
#
#			directories      # total number of dirs
#
#			binary_files     # how many bin files in total
#
#			ascii_files      # how many text files in total
#
#			size             # total size
#
#     lines            # total lines in text files (perl_* above is included
#                      # in this 'lines' value
#
#     perl_comments    # total perl standalone comments
#
#     perl_gray        # inline comment on a perl line
#
#     perl_code        # pure code lines
#
#     perl_pod         # pod lines
#
#     perl_empty       # number of empty (except whitespace) lines
# 	
#			matches => {     # files with that extension/selector
# 			...ext...
# 		}
#
#			filetypes => {   # files of that type
# 			...ftype...
# 		}
#
#		# Each file's stat() data
# 	tree => {
# 		...file... => {
#				size => (stat _)[7],
#				atime => (stat _)[8],
#				mtime => (stat _)[9],
#				ctime => (stat _)[10],
#				type  => directory/text/binary
#				(for text only below)
#				subtype> subtype (binary image, text c source, text perl source..)
#				ext   => extension as recognized by file matcher
#				lines => number of lines
#				code => lines of code
#				comments => lines of perl-style comments
#				pod => lines of POD
#				gray => mixed, same as above in total{}
#				empty => empty lines (including whitespace)
# 		}
# 	}
#
# 	# Symbols
# 	symbols => {
# 		pragma => {              # pragma symbols
# 			name => {              # pragma name
# 				file => [ line num ] # file/line-information it occurs in
# 			}
# 		}
# 	}
# )
#
#
