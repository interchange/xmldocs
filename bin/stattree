#!/usr/bin/perl
#
# docelic@icdevgroup.org
#
# Perl script to build Interchange source tree statistics,
# contexts and symbols information.
# Data is collected and dumped using Storable, that's where 
# this script's job ends.
#
# Other tools can then only read the dump to get information,
# they shouldn't parse the sources again.
#
# Now that I learned most of the requirements, looks like this
# script is up to the task and is pretty decent altogether
# 

use warnings;
use strict;
use Fatal qw/chdir/;
use File::Find;
use Data::Dumper;
use Getopt::Long;
use Storable qw/nstore_fd fd_retrieve/;
use Fcntl qw/:DEFAULT :flock/;
use File::Basename;

# Dumper behavior
$Data::Dumper::Indent = 1;
$Data::Dumper::Terse++;
$Data::Dumper::Sortkeys++;

# Vars
my $verbose = 0;
my $cachedir = $ENV{CACHE} || "cache";
my %hash; # Will contain complete data that gets dumped using Storable
my $cpath = $ENV{PWD};
# Source contexts
my $ctx_p = 10; # How much context lines to show before
my $ctx_n = 4; #                                after
my %resolver_path; # Support for stack (a -> b -> c -> d   =>
                   # a = d with full "path" recorded). This expands MapRoutines.

# All file types should be listed here or the stats wont. It should be
# reported if an unknown file is found in the archive
# Order is important. First match wins.
my %binary_types = (
	images => [qw/\.gif \.jpeg \.jpg \.png \.bmp/],
	);
my %ascii_types = (
	database => [qw|\.(..)?sql \.ora \..?dbm \.notes \.csv
		/products/\S+\.txt \.asc|],
	release_helpfile => [qw/^WHATSNEW-\d+\.\d+ README(\..+)? TODO
		^LICENSE ^MANIFEST(\.skip)? ^UPGRADE \.cvsignore \.append/],
	build_helpfile => [qw/configure ^debian.* ^SPECS.*/],
	catalog_helpfile => [qw/\.access \.log \.error \.(auto)?number \.empty/],
	config => [qw/\.cfg \.dist/],
	c => [qw/\.c \.in/],
	perl => [qw/\.pl \.pm/],
	uitag => [qw|UI_Tag/\S+\.(core)?tag dist/lib/UI/usertag/\S+|],
	systemtag => [qw|SystemTag/\S+\.(core)?tag|],
	usertag => [qw|UserTag/\S+\.tag \.tag|],
	filter => [qw/\.filter/],
	actionmap => [qw/\.am/],
	html => [qw/\.css \.html?/],
	widget => [qw/\.widget/],
	profile => [qw|/profiles/.+ \.profiles \.login \.order|],
	globalsub => [qw|/globalsub/.+|],
	variable => [qw|/vars/.+ /variables/.+|],
);


# A general overview: how many different contents do we have
my $binary_types;
my $ascii_types;
for ( keys %binary_types ) { $binary_types += scalar @{ $binary_types{$_} } }
for ( keys %ascii_types ) { $ascii_types += scalar @{ $ascii_types{$_} } }
$hash{total}{known_types} = $binary_types + $ascii_types;
$hash{total}{known_binary_types} = $binary_types;
$hash{total}{known_ascii_types} = $ascii_types;


# Parse args (not much available anyway :)
unless ( GetOptions ( 
	"verbose|v!" => \$verbose,
)) { die "Error parsing options\n" }

@ARGV == 1 or die "Usage: $0 path[/] \n";

# $path is the directory to process, $dumppath is relocated name, say
# sources/cvs-head becomes output/cvs-head/cache
my $path = shift;
( my $dumppath = $path ) =~ s#.+?/##;
my $dumpdir = $dumppath; # Directory to dump to, without file name
my %i = ( ver => $dumpdir ); # Version as read from directory name
$i{ver} =~ s/\/$//;
`mkdir -p $cachedir/$dumpdir` unless -e "$cachedir/$dumpdir";
$dumppath .= "/.cache.bin";

# Ok, onto some work now
chdir $path; # Go into the directory

# Let's just pick CVS lines first:
my @files = `find . -name Entries | cut -b 3-`;
for my $entry ( @files ) {
	chomp $entry;
	my $dir;
	( $dir = $entry ) =~ s#/?CVS/Entries$## or
		warn "Can't remove Entries\$ ('$dir')?\n";
	open CVSIN, "< $entry" or warn "Can't open '$entry' ($!)\n";
	while ( my $cvsline = <CVSIN> ) {
		next unless $cvsline =~ s#^/##;
		my ($fn, $ver, $time) = split /\//, $cvsline;

		$path = $dir ? "$dir/$fn" : $fn;
		$hash{revision}{"$path"} = [ $ver, $time ];
	}
	close CVSIN;
}

# Convenient routine to just discover all files
find({
	wanted => \&wanted,
	bydepth => 0,
	no_chdir=> 1,
}, ".");
chdir $cpath; # Return to starting location


# Dump
dumpdb( "$cachedir/$dumppath" );

# Save human-readable %hash ?
if ( $verbose ) {
	#print STDERR Dumper \%hash;
	open OUT, "> tmp/$i{ver}.hash" or die "Can't open tmp/$i{ver}.hash ($!)\n";
	print OUT Dumper \%hash;
	close OUT;
}

exit 0;

#################################################################
# Helpers below
sub wanted {
	( my $file = $_ ) =~ s/^\.\///;

	# Things we ignore
	return if /(^|\/)(CVS|\.cvs|\.svn|\.autoload)(\/.+[^\/])?$/;
	
	stat($file) or warn "Can't stat '$file' ? ($!)\n";

	# totals
	if ( -d $file ) {
		$hash{total}{directories}++;
		$hash{tree}{$file}{type} = "directory";
		return; # This is enough for directories
	} else {
		$hash{total}{files}++;
		$hash{total}{size} += (stat _)[7];
	}

	# file data itself (collected for all types)
	$hash{tree}{$file} = {
		size => (stat _)[7],
		atime => (stat _)[8],
		mtime => (stat _)[9],
		ctime => (stat _)[10],
	};

	#
	# Make sure the file extension is known (we're entering
	# content-based processing now, not filename-based as above).

	my $ftype;
	my $fsubtype;
	my $fext;
	# Binary
	for my $k ( keys %binary_types ) {
		for my $t ( @{ $binary_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "binary"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	#Text
	for my $k ( keys %ascii_types ) {
		for my $t ( @{ $ascii_types{$k} } ) {
			if ( $file =~ /$t$/i ) {
				$ftype = "ascii"; $fsubtype = "$k"; $fext = $t;
				goto EXTDONE;
			}
		}
	}
	# Unknown // pay more attention to this, this should rarely happen,
	# even if we're not interested in some files, they *should* be matched
	# in %ascii_types/%binary_types above to provide accurate statistics.
	print STDERR "$file UNKNOWN\n" if $verbose;
	return; # We're not interested in handling that

	EXTDONE:

	# file, ftype, fsubtype and fext are known here.
	# file is filename, ftype is binary/ascii, fsubtype is key in 
	# %ascii_types/%binary_types hash, fext is extension
	$hash{total}{$ftype."_files"}++;
	$hash{total}{filetypes}{$fsubtype}++;
	$hash{total}{matches}{$fext}++;
	$hash{tree}{$file}{type} = "$ftype";
	$hash{tree}{$file}{subtype} = "$fsubtype";
	$hash{tree}{$file}{ext} = "$fext";

	# No more job with binary files
	return if $ftype eq 'binary';

	# Also ignore some directories (don't parse contents in them)
	# (following a -core discussion from Aug 2004).
	return if $file =~ m#^(eg|extra|SPECS|debian|scripts|extensions)/#;

	# Open text file, parse contents
	open IN, "< $file" or die "Can't open $file ($!)\n";
	my @filedata = <IN>;
	unshift @filedata, ""; # Match index numbers with line numbers # MINUS
	close IN;

	# Global variables to use in the loop below
	my @gfunc = (qw/unknown 0/); # 2 elements: func name, line num

	# Prepare context hash so that all data is available to the
	# line handler functions later
	my %c = ( 
		file => $file,
		ftype => $ftype,
		fsubtype => $fsubtype,
		fext => $fext,
		gfunc => \@gfunc,
		filedata => \@filedata,
		ctx_p => $ctx_p,
		ctx_n => $ctx_n,
	);


	for (my $lnum = 1; $lnum < scalar @filedata; $lnum++) {
		$c{line} = $filedata[$lnum];
		$c{lnum} = $lnum;

		# Should never happen. If it does, it's critical problem.
		defined $c{line} or do {
			print STDERR "Undefined line: \n";
			print STDERR Dumper \%c;
			die;
		};

		$hash{tree}{$file}{lines}++ ;
		$hash{total}{lines}++ ;

		# BLEH!
		last if $i{ver} eq '4.6.0'
			and $c{file} =~ /Tagref\.pm$/ and $c{line} =~ /^__DATA__$/;

		# Perl program file
		if ( $c{fsubtype} eq 'perl' ) {
			my $pod = 0;
			if ( $c{line} =~ /^\s*#/ ) {
				$hash{tree}{$c{file}}{comments}++ ;
				$hash{total}{perl_comments}++;
				# TODO check if the comment contains ::log[A-Z]\w+
				# to discover calls to logGlobal/logDebug/logError
			} elsif ( $c{line} =~ /\s+#/ ) {
				$hash{tree}{$c{file}}{gray}++ ;
				$hash{total}{perl_gray}++;
			} elsif ( $c{line} =~ /^=(head|over|item)/) {
				$hash{tree}{$c{file}}{pod}++;
				$hash{total}{perl_pod}++;
				$pod++;
			} elsif ( $c{line} =~ /^=cut/) {
				$hash{tree}{$c{file}}{pod}++;
				$hash{total}{perl_pod}++;
				$pod = 0;
			} elsif ( $c{line} =~ /^\s*$/ ) {
				$hash{tree}{$c{file}}{empty}++;
				$hash{total}{perl_empty}++;
			} elsif ( ! $pod ) {
				# The default is code
				$hash{tree}{$c{file}}{code}++;
				$hash{total}{perl_code}++;

				line_findFunctionName(\%c);

				line_findPragmas(\%c);
				line_findGlobVars(\%c);
				line_findCatVars(\%c);

			} else {
				warn "IMPOSSIBLE case in $file\n";
			}

		##########################################################
		# Found a tag
		} elsif ( $c{fsubtype} =~ /^(user|ui|system)tag$/ )  {
			#$hash{total}{$fsubtype . "s"}++;

			# Skip this simple sanity check for 4.6.0 - those files do not
			# have .(core)?tag ending.
			if ( $hash{version} ne '4.6.0') {
			$c{file} =~ m#(\w+?)\.(core)?tag$# or
				warn "I know $c{file} is a tag but regex doesn't match it\n";
			}

			my %specific; # Item-specific data
			my @tags; # Support multiple tags defined in the same file

			# This is where we parse the tag file. We should discover settings like
			# HasEndTag, Order, and so on.
			for (my $lnum = 1; $lnum < scalar @filedata; $lnum++) {
				my $_l = $filedata[$lnum];
				next unless $_l =~ /^usertag\s/i;
				my @lis = split /\s+/, $_l;
				shift @lis; # Remove "Usertag" which is first in the list

				# Tag name as really defined, not just the file name
				# (Most often, the difference is in _ and -).
				my $tn = shift @lis;

				my $tagopt = lc(shift @lis);
				next if $tagopt =~ /^documentation$/;

				# See if it's a routine and parse routine lines as usual perl lines
				if ( $tagopt =~ /^routine$/ and "@lis" =~ /\s*<<(\S+)\s*$/i ) {
					my $ender = $1;
					for (my $lnum2 = $lnum; $lnum2 < scalar @filedata; $lnum2++) {
						my $_t = $filedata[$lnum2];
						last if $_t =~ /^$ender$/;

						$c{line} = $_t;
						$c{lnum} = $lnum2;

						line_findPragmas(\%c, {group =>$c{fsubtype}, name=>$tn});
						# For example, this should find PGP_HOME
						line_findGlobVars(\%c, {group => $c{fsubtype}, name=>$tn});
						line_findCatVars(\%c, {group => $c{fsubtype}, name=>$tn});
						line_findFunctionName(\%c, {group => $c{fsubtype}, name=>$tn});
					}
					next;

				} elsif ( $tagopt =~ /^maproutine$/ ) {

					@lis == 1 or die "$tn MapRoutines, but argc != 1 ?\n";
					next if "@lis" =~ /^::/; # TODO
					file_extractSub($tn, "@lis", \%c, {group => $c{fsubtype},name=>$tn});
				}
				
				if ( "@lis" =~ /<</ and $tagopt !~ /^routine/ ) {
					warn "TODO: Unsupported << in $tn (in $i{ver})\n" if $verbose;
					next;
				}

				# New tag name we didn't see yet
				# (either first run or another tag definition in the same file)
				{ no warnings;
				if (!grep{/^$tn$/}@tags and $lis[0] !~ /^alias$/i) { push @tags, $tn }
				}

				$specific{$tn}{"_tagopt_$tagopt"} = "@lis";
			}
			
			# For each tag found in the file, create appropriate data in hash.
			for my $tagname ( @tags ) {
				push @{ $hash{symbols}{$c{fsubtype}}{$tagname} }, {
					%c,
					file => "$i{ver}/$c{file}",
					lnum => scalar @filedata,
					ctxpre => $ctx_p,
					ctxpost => $ctx_n,
					ctxs => 1,
					ctxe => scalar @filedata,
					ctx => [ format_ctx(@filedata) ]
				};

				$hash{total}{$fsubtype . "s"}++;
				$hash{total}{tags}++;

				$hash{specific}{$tagname} = { # Append/update, don't overwrite
					%{ $hash{specific}{$tagname} || {}},
					%{ $specific{$tagname} || {}},
				};

				# Push whole resolved chain; last item is actual function
				if ( $resolver_path{$tagname} ) {
					while ( my $spath = shift @{ $resolver_path{$tagname} } ) {
						push @{ $hash{symbols}{$c{fsubtype}}{$tagname} }, {
							ctxpre => 0,
							ctxpost => 0,
							%$spath,
						};
					}
				}
			}
			last;

		##########################################################
		# Found a filter
		} elsif ( $c{fsubtype} =~ /^filter$/ )  {
			( my $fn = $file ) =~ s#.+/##;
			$fn =~ s/\.filter$//;

			push @{ $hash{symbols}{$c{fsubtype}}{$fn} }, {
				%c,
				file => "$i{ver}/$c{file}",
				lnum => scalar @filedata,
				ctxpre => $ctx_p,
				ctxpost => $ctx_n,
				ctxs => 1,
				ctxe => scalar @filedata,
				ctx => [ format_ctx(@filedata) ]
			};

			$hash{total}{$fsubtype . "s"}++;
			last;
		}
	} # END FOR each line

	# Now in addition to above general line-by-line processing, do some more
	# processing on exactly *some* files:

	####################################################################
	# It's the main configure file, pick up the ICVERSION variable
	if ( $c{file} eq 'configure' ) {
		for $_ (@filedata) {
			if ( /^ICVERSION=(['"])(\d+\.\d+\.\d+)\1/ ) {
				if ( !$hash{version} or "$hash{version}" eq "$2" ) {
					$hash{version} = $2
				}
				last;
			}
		}
		# ICVERSION must be known here, or someone's playing, or
		# it's a pre-5.0 version which doesnt have that.
		unless ( $hash{version} ) {
			warn "Wasn't able to determine " .
				'^ICVERSION=([\'"])(\d+\.\d+\.\d+)\1 from the main ' .
				"./configure script. Will use one from directory name ($i{ver}).\n"
				unless $i{ver} =~ /^4/; # ignore warning for 4.x versions
				$hash{version} = $i{ver};
		}
	}

	####################################################################
	# lib/Vend/Config.pm
	if ( $c{file} eq 'lib/Vend/Config.pm' ) {
		file_parseVendConfig(\%c, \@filedata);
	}
}

# Format the context lines before saving to the db
sub format_ctx {
	for $_ ( @_ ) { s/\t/  /g; chomp };

	my $common;
	for my $str ( @_ ) {
		# Behave long lines
		my $len = length $str; my $pos = 70;
		while ( $len > 100 ) {
			$str =~ s/^(.{$pos}.*?)([\s<\&\?\|\(])/$1 \\\n$2/s;
			$pos += 70; $len -= 70;
		}


		# Find the number of starting whitespace common to all lines
		if ($str =~ /\S/ and $str =~ /^( +)/) {
			$common = length($1) if !defined $common || length($1) < $common
		}
	}

	# Do as above loop decided
	if ( $common ) { s/^ {$common}// for @_ }

	return @_;
}

# Storable dumper
sub dumpdb {

	my $dbpath = shift;

	sysopen( OUT, $dbpath, O_WRONLY|O_CREAT, 0664 ) or
		die "Can't dump ($dbpath) ($!).\n";
	flock( OUT, LOCK_EX ) or
		die "Can't exclusive-lock ($dbpath) ($!).\n";;
	nstore_fd(\%hash, \*OUT ) or
		die "Can't dump to ($dbpath) ($!).\n";
	truncate( OUT, tell(OUT));
	close OUT or
		die "Can't properly close database ($dbpath) ($!).\n";

}

# HELPERS

sub line_findPragmas {
	my %c = %{ (shift) };
	my $context_data = shift;
	
	# This matches $::Pragma->{} or $$::Pragma{}
	#if ( $line =~ /(()|\$())\$::Pragma(->\2|\3){(\w+?)}/ ) {
	if ( $c{line} =~ /\$::Pragma->{(\w+?)}/ or         
			$c{line} =~ /\$Vend::Cfg->{Pragma}{(\w+?)}/ ) {
	#push @{ $hash{symbols}{pragma}{$5} }, <- for use with above
		push @{ $hash{symbols}{pragma}{$1} }, {
	# TODO Here, and 2 places below: make sure if ctx is say, 5:5,
	# it always shows that much (that is, workaround file beginning/
	# file end problems - pad with empty lines or something).
		%c,
		file => "$i{ver}/$c{file}",
		lnum => $c{lnum},
		func => ${$c{gfunc}}[0],
		funclnum => ${$c{gfunc}}[1],
		ctxpre => $c{ctx_p},
		ctxpost => $c{ctx_n},
		ctxs => $c{lnum} - $c{ctx_p},
		ctxe => $c{lnum} + $c{ctx_n},
		ctx => [format_ctx(@{$c{filedata}}[$c{lnum}-$c{ctx_p}..$c{lnum}+$c{ctx_n}])]
	};

	if ( $context_data or $c{gfunc}) {
		!$context_data and do {
			$context_data = {
				group => 'function',
				name => ${$c{gfunc}}[0],
			}
		};
		push(@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{pragma}},
		$1) unless grep {/^$1$/}
			@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{pragma}}
	}

		$hash{total}{pragmas}++;
	}
}

sub line_findCatVars {
	######################################################
	# Diskover global variables
	my %c = %{ (shift) };
	my $context_data = shift;

	my $name;

	if (
		($c{line} =~ /(()|\$())\$(::)?Variable(->\2|\3){(\w+?)}/ and $name=$6)
		or ($c{line}=~/\$Tag->var\s*\(\s*(["'])(\S+?)\1(\s*,\s*(2))?/ and $name=$5)
		or ($c{line} =~ /[^_\/]__([^_]\w+?)__[^_\/]/ and
			( $1 !~ /^(END|DIE|MYVAR|PACKAGE|NAME|none|WARN)$/) and $name=$1)
		or ($c{line} =~ /\[var (\S+?)\]/i and $name=$1)
		or ($c{line} =~ /\[var (\S+?)\s+2\s*\]/i and $name=$1)
		) {

		push @{ $hash{symbols}{catvar}{$name} }, {
			%c,
			file => "$i{ver}/$c{file}",
			lnum => $c{lnum},
			func => ${$c{gfunc}}[0],
			funclnum => ${$c{gfunc}}[1],
			ctxpre => $c{ctx_p},
			ctxpost => $c{ctx_n},
			ctxs => $c{lnum} - $c{ctx_p},
			ctxe => $c{lnum} + $c{ctx_n},
			ctx => [format_ctx(@{$c{filedata}}[$c{lnum}-$c{ctx_p}..$c{lnum}+$c{ctx_n}])]
		};

		if ( $context_data or $c{gfunc} ) {
			!$context_data and $context_data = {
				group => 'function',
				name => ${$c{gfunc}}[0],
			};
			push(
				@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{catvar}},
					$name) unless grep {/^$name$/}
			@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{catvar}}
		}

		$hash{total}{catvars}++;
	}
}

sub line_findGlobVars {
	######################################################
	# Diskover global variables
	my %c = %{ (shift) };
	my $context_data = shift;

	my $name;

	if (
		($c{line} =~ /(()|\$())\$Global::Variable(->\2|\3){(\w+?)}/ and $name=$5)
		or ($c{line}=~/\$Tag->var\s*\(\s*(["'])(\S+?)\1(\s*,\s*(\d))?/ and $name=$5)
		or ($c{line} =~ /[^\/]\@[_\@](\w+?)[_\@]\@[^\/]/ and $name=$1)
		or ($c{line} =~ /\[var (\S+?)\s+1\s*\]/i and $name=$1)
		) {
		push @{ $hash{symbols}{globvar}{$name} }, {
			%c,
			file => "$i{ver}/$c{file}",
			lnum => $c{lnum},
			func => ${$c{gfunc}}[0],
			funclnum => ${$c{gfunc}}[1],
			ctxpre => $c{ctx_p},
			ctxpost => $c{ctx_n},
			ctxs => $c{lnum} - $c{ctx_p},
			ctxe => $c{lnum} + $c{ctx_n},
			ctx => [format_ctx(@{$c{filedata}}[$c{lnum}-$c{ctx_p}..$c{lnum}+$c{ctx_n}])]
		};

		if ( $context_data or $c{gfunc} ) {
			!$context_data and $context_data = {
				group => 'function',
				name => ${$c{gfunc}}[0],
			};
			#print "$$context_data{name}\n" if $$context_data{group} eq 'function';
			push(
				@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{globvar}},
					$name) unless grep {/^$name$/}
			@{$hash{uses}{$$context_data{group}}{$$context_data{name}}{globvar}}
		}

		$hash{total}{globvars}++;
	}
}

sub line_findFunctionName {
	######################################################
	# See if it's a beginning of a subroutine name, and remember the
	# name/linenum.
	my $c = shift;
	if ( $$c{line} =~ m#^\s*sub\s+(\w+)\s*\{\s*$# ) {
		$hash{total}{perl_functions}++;
		@{ $$c{gfunc} } = ( $1, $$c{lnum} );
	}

	$hash{total}{functions}++;
}


sub file_parseVendConfig {
	my %c = %{ (shift) };
	my $content = shift; # Complete lib/Vend/Config.pm file

	my $linenr = -1;     # Increases as we parse Config.pm (search "MINUS" above)
	my $startline;       # Remember first line nr. of context, not last
	my $context = "";    # Globconf (global) or catconf (catalog) config array
	my $run = 0;         # Engine turned on?
	my $multiline;       # Directive definition spans multiple lines?
	my $opens;           # Open brackets. When 0, complete directive is read
	my $directive;       # Directive text
	my $globalclose;     # Just used for simple error catching
	my @globconf;        # Directives, each directive in its own entry
	my @catconf;         # Directives, each directive in its own entry

	for my $line (@$content) {
		$linenr++;

		goto MULTILINE if $multiline;
		$startline = $linenr;
		
		# Determine context
		if ( $line =~ /^sub\s+global_directives\s+{\s*$/ ) {
			$context = "globconf";
			next;
		}
		if ( $line =~ /^sub\s+catalog_directives\s+{\s*$/ ) {
			$context = "catconf";
			next;
		}
		# The following check is redundant with "} else { ...; $run = 0 }" below
		if ( $line =~ /return \$directives/ ) {
			$context = "";
			$run = 0;
			next
		}
		if ( $context and $line =~ /my \$directives = \[/ ){
			$run++; next
		}
		#}} unconfuse vim

		next unless $context and $run;

		MULTILINE:
		next unless $context;
		next unless length $line;
		next if $line =~ /^\s*$/;
		next if $line =~ /^\s*#/;

		# Count braces
		# If this code gets non-working for a particular case,
		# add support for escapes (negative lookbehind): (?<!\\)
		# Or even more, the code below in file_extractSub has support for
		# correcty parsing {\\} . Bleh ;-)
		$opens += ( $line =~ s/([\(\[\{])/$1/g );
		$opens -= ( $line =~ s/([\)\]\}])/$1/g );
		$directive .= $line;

		if (! $opens) { # Read the whole thing
			$multiline = 0;

			# Register the directive and do some statistics
			if ( $context eq 'globconf' ) {
				push @globconf, [ $directive, $startline ] ;
				$hash{total}{globconfs}++;
			} elsif ( $context eq 'catconf' ){
				push @catconf, [ $directive, $startline ];
				$hash{total}{catconfs}++;
			}
			$hash{total}{confs}++;

			$directive = "";
		} elsif ( $opens > 0 ) { # Directive continues
			$multiline++;
			next;
		} else { # Too many closing brackets
			$globalclose++;
			$run = 0;
			$opens = 0; $directive = ""; # BLAM! Took me a while to figure those two out
			# This is okay, verified to only happen at closing of the 
			# opening of "my $directives = [" which is not counted.
			#die "Holy moustache! at $linenr: $line\n";
		}
	} # END for()

	$globalclose == 2 or die "Assert globalclose == 2: $globalclose\n";

	# Well, let's congratulate ourselves.

	for my $itm (@globconf) {
		my ($ln, $lnum) = @$itm;
		$ln =~ /^\s*\['(\S+?)'/ or die "Can't match global directive name in '$ln'?\n";
		push @{ $hash{symbols}{globconf}{$1} }, {
			%c,
			lnum => $lnum,
			ctx => [ format_ctx(split(/\n/, $ln)) ],
		}
	}
	for my $itm (@catconf) {
		my ($ln, $lnum) = @$itm;
		$ln =~ /^\s*\['(\S+?)'/ or die "Can't match catalog directive name in '$ln'?\n";
		push @{ $hash{symbols}{catconf}{$1} }, {
			%c,
			lnum => $lnum,
			ctx => [ format_ctx(split(/\n/, $ln)) ],
		}
	}
}


sub file_extractSub {
	my $tagname = shift;
	my $func = shift;
	my $c = shift;
	my $context_data = shift;

	my $done = 0;
	$func or die "file_extractSub with no args?\n";
	my ( $start, $end );
	my ($content,@content);

	my @path = split /::/, $func;
	$func = pop @path;
	my $path = join("/", @path) . ".pm";

	open INF, "< lib/$path" or die "Can't open 'lib/$path' ($!)\n";
	my @fc = <INF>;
	close INF;

	for ( my $i = 0; $i < @fc; $i++ ) {
		my $line = $fc[$i];

		if ( $line =~ /^\*$func = \\\&(\S+);/ ) {
			push @{ $resolver_path{$tagname} }, {
				name => $func,
				file => "lib/$path",
				lnum => $start,
				ctxs => $i,
				ctxe => $i,
				ctx_p => 0,
				ctx_n => 0,
				ctx => [ format_ctx($line) ],
			};
			file_extractSub( $tagname, $1, $c, $context_data);
			return;

		} elsif ( $line =~ /^sub $func \{/ ) {
			$start = $i+1 unless $start;
			@content = ($line);

			# Quick and dirty extractor. This same functionality is in 
			# file_parseVendConfig() above but is written too much purpose-specific
			# to generalize it.
			my $opens = 1; # Oh you dirty one..
			for ( my $j = $i+1; $j < @fc; $j++) {
				my $line2 = $fc[$j];
				$opens += ( $line2 =~ s/(?<!(?<!\\)\\)([\(\[\{])/$1/g );
				$opens -= ( $line2 =~ s/(?<!(?<!\\)\\)([\)\]\}])/$1/g );
				push @content, $line2;
				if ( !$opens) { $done++; $end = $j+1; last }
			}

			die "NOT FOUND FOR $func ?\n" unless $done;
		}
	}

	# func in lib/$path from $start to $end
	$content = join '', @content;
	push @{ $resolver_path{$tagname} }, {
		name => $func,
		file => "lib/$path",
		lnum => $start,
		ctxs => $start,
		ctxe => $end,
		ctx_p => 0,
		ctx_n => 0,
		ctx => [ format_ctx(split(/\n/, $content)) ],
	};
}

